Copyright (c) 2013, Timothy Buktu

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

------------------------------------------------------------------------------

--- jdk8/jdk/test/java/math/BigInteger/BigIntegerTest.java	2013-03-09 11:31:52.000000000 +0100
+++ src/test/java/BigIntegerTest.java	2013-05-06 18:49:33.291372943 +0200
@@ -39,8 +39,8 @@
  * this test is a strong assurance that the BigInteger operations
  * are working correctly.
  *
- * Three arguments may be specified which give the number of
- * decimal digits you desire in the three batches of test numbers.
+ * Five arguments may be specified which give the number of
+ * decimal digits you desire in the five batches of test numbers.
  *
  * The tests are performed on arrays of random numbers which are
  * generated by a Random class as well as special cases which
@@ -50,19 +50,15 @@
 public class BigIntegerTest {
     static Random rnd = new Random();
     static int size = 1000; // numbers per batch
+    static int reducedSize = 10;   // numbers per batch in the Schoenhage-Strassen/Barrett range
     static boolean failure = false;
 
-    // Some variables for sizing test numbers in bits
-    private static int order1 = 100;
-    private static int order2 = 60;
-    private static int order3 = 30;
-
-    public static void pow() {
+    public static void pow(int order) {
         int failCount1 = 0;
 
         for (int i=0; i<size; i++) {
             int power = rnd.nextInt(6) +2;
-            BigInteger x = fetchNumber(order1);
+            BigInteger x = fetchNumber(order);
             BigInteger y = x.pow(power);
             BigInteger z = x;
 
@@ -75,16 +71,17 @@
         report("pow", failCount1);
     }
 
-    public static void arithmetic() {
+    public static void arithmetic(int order) {
         int failCount = 0;
 
-        for (int i=0; i<size; i++) {
-            BigInteger x = fetchNumber(order1);
+        int iterations = order<100000 ? size : reducedSize;
+        for (int i=0; i<iterations; i++) {
+            BigInteger x = fetchNumber(order);
             while(x.compareTo(BigInteger.ZERO) != 1)
-                x = fetchNumber(order1);
-            BigInteger y = fetchNumber(order1/2);
+                x = fetchNumber(order);
+            BigInteger y = fetchNumber(order/2);
             while(x.compareTo(y) == -1)
-                y = fetchNumber(order1/2);
+                y = fetchNumber(order/2);
             if (y.equals(BigInteger.ZERO))
                 y = y.add(BigInteger.ONE);
 
@@ -95,16 +92,16 @@
             if (!baz.equals(BigInteger.ZERO))
                 failCount++;
         }
-        report("Arithmetic I", failCount);
+        report("Arithmetic I for " + order + " bits", failCount);
 
         failCount = 0;
         for (int i=0; i<100; i++) {
-            BigInteger x = fetchNumber(order1);
+            BigInteger x = fetchNumber(order);
             while(x.compareTo(BigInteger.ZERO) != 1)
-                x = fetchNumber(order1);
-            BigInteger y = fetchNumber(order1/2);
+                x = fetchNumber(order);
+            BigInteger y = fetchNumber(order/2);
             while(x.compareTo(y) == -1)
-                y = fetchNumber(order1/2);
+                y = fetchNumber(order/2);
             if (y.equals(BigInteger.ZERO))
                 y = y.add(BigInteger.ONE);
 
@@ -115,7 +112,33 @@
             if (!baz[0].equals(BigInteger.ZERO))
                 failCount++;
         }
-        report("Arithmetic II", failCount);
+        report("Arithmetic II for " + order + " bits", failCount);
+    }
+
+    // Tests SS edge cases by multiplying numbers of the form 2^n + {-1,0,1}
+    public static void schoenhageStrassen() {
+        int failCount = 0;
+
+        for (int i=0; i<10; i++) {
+            int m = 1 << (23+rnd.nextInt(3));
+            BigInteger x = ONE.shiftLeft(m);
+            BigInteger xd = BigInteger.valueOf(rnd.nextInt(3) - 1);
+
+            int n = 1 << (23+rnd.nextInt(3));
+            BigInteger y = ONE.shiftLeft(n);
+            BigInteger yd = BigInteger.valueOf(rnd.nextInt(3) - 1);
+
+            BigInteger product = x.add(xd).multiply(y.add(yd));
+            BigInteger expected = ONE.shiftLeft(m + n);
+            expected = expected.add(x.multiply(yd));
+            expected = expected.add(y.multiply(xd));
+            expected = expected.add(xd.multiply(yd));
+
+            if (!product.equals(expected)) {
+                failCount++;
+            }
+        }
+        report("Schoenhage-Strassen", failCount);
     }
 
     public static void bitCount() {
@@ -160,11 +183,11 @@
         report("BitLength", failCount);
     }
 
-    public static void bitOps() {
+    public static void bitOps(int order) {
         int failCount1 = 0, failCount2 = 0, failCount3 = 0;
 
         for (int i=0; i<size*5; i++) {
-            BigInteger x = fetchNumber(order1);
+            BigInteger x = fetchNumber(order);
             BigInteger y;
 
             /* Test setBit and clearBit (and testBit) */
@@ -194,7 +217,7 @@
         report("flipBit/testBit", failCount2);
 
         for (int i=0; i<size*5; i++) {
-            BigInteger x = fetchNumber(order1);
+            BigInteger x = fetchNumber(order);
 
             /* Test getLowestSetBit() */
             int k = x.getLowestSetBit();
@@ -213,13 +236,13 @@
         report("getLowestSetBit", failCount3);
     }
 
-    public static void bitwise() {
+    public static void bitwise(int order) {
 
         /* Test identity x^y == x|y &~ x&y */
         int failCount = 0;
         for (int i=0; i<size; i++) {
-            BigInteger x = fetchNumber(order1);
-            BigInteger y = fetchNumber(order1);
+            BigInteger x = fetchNumber(order);
+            BigInteger y = fetchNumber(order);
             BigInteger z = x.xor(y);
             BigInteger w = x.or(y).andNot(x.and(y));
             if (!z.equals(w))
@@ -230,8 +253,8 @@
         /* Test identity x &~ y == ~(~x | y) */
         failCount = 0;
         for (int i=0; i<size; i++) {
-            BigInteger x = fetchNumber(order1);
-            BigInteger y = fetchNumber(order1);
+            BigInteger x = fetchNumber(order);
+            BigInteger y = fetchNumber(order);
             BigInteger z = x.andNot(y);
             BigInteger w = x.not().or(y).not();
             if (!z.equals(w))
@@ -240,13 +263,13 @@
         report("Logic (&~ | ~)", failCount);
     }
 
-    public static void shift() {
+    public static void shift(int order) {
         int failCount1 = 0;
         int failCount2 = 0;
         int failCount3 = 0;
 
         for (int i=0; i<100; i++) {
-            BigInteger x = fetchNumber(order1);
+            BigInteger x = fetchNumber(order);
             int n = Math.abs(rnd.nextInt()%200);
 
             if (!x.shiftLeft(n).equals
@@ -279,13 +302,14 @@
         report("baz shiftLeft/Right", failCount3);
     }
 
-    public static void divideAndRemainder() {
+    public static void divideAndRemainder(int order) {
         int failCount1 = 0;
 
-        for (int i=0; i<size; i++) {
-            BigInteger x = fetchNumber(order1).abs();
+        int iterations = order<100000 ? size : reducedSize;
+        for (int i=0; i<iterations; i++) {
+            BigInteger x = fetchNumber(order).abs();
             while(x.compareTo(BigInteger.valueOf(3L)) != 1)
-                x = fetchNumber(order1).abs();
+                x = fetchNumber(order).abs();
             BigInteger z = x.divide(BigInteger.valueOf(2L));
             BigInteger y[] = x.divideAndRemainder(x);
             if (!y[0].equals(BigInteger.ONE)) {
@@ -306,7 +330,7 @@
                 System.err.println("      y :"+y);
             }
         }
-        report("divideAndRemainder I", failCount1);
+        report("divideAndRemainder for " + order + " bits", failCount1);
     }
 
     public static void stringConv() {
@@ -331,13 +355,13 @@
         report("String Conversion", failCount);
     }
 
-    public static void byteArrayConv() {
+    public static void byteArrayConv(int order) {
         int failCount = 0;
 
         for (int i=0; i<size; i++) {
-            BigInteger x = fetchNumber(order1);
+            BigInteger x = fetchNumber(order);
             while (x.equals(BigInteger.ZERO))
-                x = fetchNumber(order1);
+                x = fetchNumber(order);
             BigInteger y = new BigInteger(x.toByteArray());
             if (!x.equals(y)) {
                 failCount++;
@@ -348,16 +372,17 @@
         report("Array Conversion", failCount);
     }
 
-    public static void modInv() {
+    public static void modInv(int order) {
         int failCount = 0, successCount = 0, nonInvCount = 0;
 
-        for (int i=0; i<size; i++) {
-            BigInteger x = fetchNumber(order1);
+        int iterations = order<100000 ? size : reducedSize;
+        for (int i=0; i<iterations; i++) {
+            BigInteger x = fetchNumber(order);
             while(x.equals(BigInteger.ZERO))
-                x = fetchNumber(order1);
-            BigInteger m = fetchNumber(order1).abs();
+                x = fetchNumber(order);
+            BigInteger m = fetchNumber(order).abs();
             while(m.compareTo(BigInteger.ONE) != 1)
-                m = fetchNumber(order1).abs();
+                m = fetchNumber(order).abs();
 
             try {
                 BigInteger inv = x.modInverse(m);
@@ -374,10 +399,10 @@
                 nonInvCount++;
             }
         }
-        report("Modular Inverse", failCount);
+        report("Modular Inverse for " + order + " bits", failCount);
     }
 
-    public static void modExp() {
+    public static void modExp(int order1, int order2) {
         int failCount = 0;
 
         for (int i=0; i<size/10; i++) {
@@ -404,7 +429,7 @@
     // This test is based on Fermat's theorem
     // which is not ideal because base must not be multiple of modulus
     // and modulus must be a prime or pseudoprime (Carmichael number)
-    public static void modExp2() {
+    public static void modExp2(int order) {
         int failCount = 0;
 
         for (int i=0; i<10; i++) {
@@ -412,11 +437,11 @@
             while(m.compareTo(BigInteger.ONE) != 1)
                 m = new BigInteger(100, 5, rnd);
             BigInteger exp = m.subtract(BigInteger.ONE);
-            BigInteger base = fetchNumber(order1).abs();
+            BigInteger base = fetchNumber(order).abs();
             while(base.compareTo(m) != -1)
-                base = fetchNumber(order1).abs();
+                base = fetchNumber(order).abs();
             while(base.equals(BigInteger.ZERO))
-                base = fetchNumber(order1).abs();
+                base = fetchNumber(order).abs();
 
             BigInteger one = base.modPow(exp, m);
             if (!one.equals(BigInteger.ONE)) {
@@ -703,6 +728,12 @@
      *
      */
     public static void main(String[] args) throws Exception {
+        // Some variables for sizing test numbers in bits
+        int order1 = 100;
+        int order2 = 60;
+        int order3 = 3600;   // #bits for testing Karatsuba and Burnikel-Ziegler
+        int order4 = 6000;   // #bits for testing Toom-Cook
+        int order5 = 3500000; // #bits for testing Schoenhage-Strassen and Barrett
 
         if (args.length >0)
             order1 = (int)((Integer.parseInt(args[0]))* 3.333);
@@ -710,26 +741,43 @@
             order2 = (int)((Integer.parseInt(args[1]))* 3.333);
         if (args.length >2)
             order3 = (int)((Integer.parseInt(args[2]))* 3.333);
+        if (args.length >3)
+            order4 = (int)((Integer.parseInt(args[3]))* 3.333);
+        if (args.length >4)
+            order5 = (int)((Integer.parseInt(args[4]))* 3.333);
 
         prime();
         nextProbablePrime();
 
-        arithmetic();
-        divideAndRemainder();
-        pow();
+        schoenhageStrassen();
+
+        arithmetic(order1);   // small numbers
+        arithmetic(order3);   // Karatsuba / Burnikel-Ziegler range
+        arithmetic(order4);   // Toom-Cook range
+        arithmetic(order5);   // SS/Barrett range
+
+        divideAndRemainder(order1);   // small numbers
+        divideAndRemainder(order3);   // Karatsuba / Burnikel-Ziegler range
+        divideAndRemainder(order4);   // Toom-Cook range
+        divideAndRemainder(order5);   // SS/Barrett range
+
+        pow(order1);
 
         bitCount();
         bitLength();
-        bitOps();
-        bitwise();
+        bitOps(order1);
+        bitwise(order1);
+
+        shift(order1);
 
-        shift();
+        byteArrayConv(order1);
 
-        byteArrayConv();
+        modInv(order1);   // small numbers
+        modInv(order3);   // Karatsuba / Burnikel-Ziegler range
+        modInv(order4);   // Toom-Cook range
 
-        modInv();
-        modExp();
-        modExp2();
+        modExp(order1, order2);
+        modExp2(order1);
 
         stringConv();
         serialize();
@@ -747,7 +795,7 @@
      */
     private static BigInteger fetchNumber(int order) {
         boolean negative = rnd.nextBoolean();
-        int numType = rnd.nextInt(6);
+        int numType = rnd.nextInt(7);
         BigInteger result = null;
         if (order < 2) order = 2;
 
@@ -775,12 +823,25 @@
                 break;
 
             case 4: // Random bit density
-                int iterations = rnd.nextInt(order-1);
-                result = BigInteger.ONE.shiftLeft(rnd.nextInt(order));
-                for(int i=0; i<iterations; i++) {
-                    BigInteger temp = BigInteger.ONE.shiftLeft(
-                                                rnd.nextInt(order));
-                    result = result.or(temp);
+                byte[] val = new byte[(order+7)/8];
+                int iterations = rnd.nextInt(order);
+                for (int i=0; i<iterations; i++) {
+                    int bitIdx = rnd.nextInt(order);
+                    val[bitIdx/8] |= 1 << (bitIdx%8);
+                }
+                result = new BigInteger(1, val);
+                break;
+            case 5: // Runs of consecutive ones and zeros
+                result = ZERO;
+                int remaining = order;
+                int bit = rnd.nextInt(2);
+                while (remaining > 0) {
+                    int runLength = Math.min(remaining, rnd.nextInt(order));
+                    result = result.shiftLeft(runLength);
+                    if (bit > 0)
+                        result = result.add(ONE.shiftLeft(runLength).subtract(ONE));
+                    remaining -= runLength;
+                    bit = 1 - bit;
                 }
                 break;
 
