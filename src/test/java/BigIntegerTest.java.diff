Copyright (c) 2013, Alan Eliasen
Copyright (c) 2013, Timothy Buktu

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

------------------------------------------------------------------------------

--- ./jdk8/jdk/test/java/math/BigInteger/BigIntegerTest.java	2013-03-09 11:31:52.000000000 +0100
+++ ./src/test/java/BigIntegerTest.java	2013-05-13 02:39:57.250829913 +0200
@@ -32,6 +32,9 @@
 import java.util.Random;
 import java.math.BigInteger;
 import java.io.*;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
+import java.util.*;
 
 /**
  * This is a simple test class created to ensure that the results
@@ -39,8 +42,8 @@
  * this test is a strong assurance that the BigInteger operations
  * are working correctly.
  *
- * Three arguments may be specified which give the number of
- * decimal digits you desire in the three batches of test numbers.
+ * Five arguments may be specified which give the number of
+ * decimal digits you desire in the five batches of test numbers.
  *
  * The tests are performed on arrays of random numbers which are
  * generated by a Random class as well as special cases which
@@ -50,19 +53,15 @@
 public class BigIntegerTest {
     static Random rnd = new Random();
     static int size = 1000; // numbers per batch
+    static int reducedSize = 10;   // numbers per batch in the Schoenhage-Strassen/Barrett range
     static boolean failure = false;
 
-    // Some variables for sizing test numbers in bits
-    private static int order1 = 100;
-    private static int order2 = 60;
-    private static int order3 = 30;
-
-    public static void pow() {
+    public static void pow(int order) {
         int failCount1 = 0;
 
         for (int i=0; i<size; i++) {
             int power = rnd.nextInt(6) +2;
-            BigInteger x = fetchNumber(order1);
+            BigInteger x = fetchNumber(order);
             BigInteger y = x.pow(power);
             BigInteger z = x;
 
@@ -75,16 +74,17 @@
         report("pow", failCount1);
     }
 
-    public static void arithmetic() {
+    public static void arithmetic(int order) {
         int failCount = 0;
 
-        for (int i=0; i<size; i++) {
-            BigInteger x = fetchNumber(order1);
+        int iterations = order<100000 ? size : reducedSize;
+        for (int i=0; i<iterations; i++) {
+            BigInteger x = fetchNumber(order);
             while(x.compareTo(BigInteger.ZERO) != 1)
-                x = fetchNumber(order1);
-            BigInteger y = fetchNumber(order1/2);
+                x = fetchNumber(order);
+            BigInteger y = fetchNumber(order/2);
             while(x.compareTo(y) == -1)
-                y = fetchNumber(order1/2);
+                y = fetchNumber(order/2);
             if (y.equals(BigInteger.ZERO))
                 y = y.add(BigInteger.ONE);
 
@@ -95,16 +95,16 @@
             if (!baz.equals(BigInteger.ZERO))
                 failCount++;
         }
-        report("Arithmetic I", failCount);
+        report("Arithmetic I for " + order + " bits", failCount);
 
         failCount = 0;
         for (int i=0; i<100; i++) {
-            BigInteger x = fetchNumber(order1);
+            BigInteger x = fetchNumber(order);
             while(x.compareTo(BigInteger.ZERO) != 1)
-                x = fetchNumber(order1);
-            BigInteger y = fetchNumber(order1/2);
+                x = fetchNumber(order);
+            BigInteger y = fetchNumber(order/2);
             while(x.compareTo(y) == -1)
-                y = fetchNumber(order1/2);
+                y = fetchNumber(order/2);
             if (y.equals(BigInteger.ZERO))
                 y = y.add(BigInteger.ONE);
 
@@ -115,7 +115,372 @@
             if (!baz[0].equals(BigInteger.ZERO))
                 failCount++;
         }
-        report("Arithmetic II", failCount);
+        report("Arithmetic II for " + order + " bits", failCount);
+    }
+
+    public static void schoenhageStrassen(int order) throws Exception {
+        int failCount = 0;
+        Random rnd = new Random();
+
+        // test edge cases by multiplying numbers of the form 2^n + {-1,0,1}
+        for (int i=0; i<10; i++) {
+            int m = 1 << (23+rnd.nextInt(3));
+            BigInteger x = ONE.shiftLeft(m);
+            BigInteger xd = BigInteger.valueOf(rnd.nextInt(3) - 1);
+
+            int n = 1 << (23+rnd.nextInt(3));
+            BigInteger y = ONE.shiftLeft(n);
+            BigInteger yd = BigInteger.valueOf(rnd.nextInt(3) - 1);
+
+            BigInteger product = x.add(xd).multiply(y.add(yd));
+            BigInteger expected = ONE.shiftLeft(m + n);
+            expected = expected.add(yd.shiftLeft(m));   // add x.multiply(yd)
+            expected = expected.add(xd.shiftLeft(n));   // add y.multiply(xd)
+            expected = expected.add(xd.multiply(yd));
+
+            if (!product.equals(expected)) {
+                failCount++;
+            }
+        }
+
+        // test square()
+        Method squareMethod = BigInteger.class.getDeclaredMethod("square");
+        squareMethod.setAccessible(true);
+        for (int i=0; i<10; i++) {
+            int m = 1 << (23+rnd.nextInt(3));
+            BigInteger x = ONE.shiftLeft(m);
+            BigInteger xd = BigInteger.valueOf(rnd.nextInt(3) - 1);
+
+            BigInteger square = (BigInteger)squareMethod.invoke(x.add(xd));
+            BigInteger expected = ONE.shiftLeft(2 * m);
+            expected = expected.add(xd.shiftLeft(m+1));   // add 2*x.multiply(yd)
+            expected = expected.add(xd.multiply(xd));
+
+            if (!square.equals(expected)) {
+                failCount++;
+            }
+        }
+
+        // verify that idft(dft(a)) = a
+        Method modFnMethod = BigInteger.class.getDeclaredMethod("modFn", int[][].class);
+        modFnMethod.setAccessible(true);
+        Method dftMethod = BigInteger.class.getDeclaredMethod("dft", int[][].class, int.class, int.class);
+        dftMethod.setAccessible(true);
+        Method idftMethod = BigInteger.class.getDeclaredMethod("idft", int[][].class, int.class, int.class);
+        idftMethod.setAccessible(true);
+        for (int k=0; k<100; k++) {
+            int m = 8 + rnd.nextInt(8);
+            int n = m/2 + 1;
+            int[][] a = createRandomDftArray(m, n);
+            modFnMethod.invoke(null, new Object[] {a});
+            int[][] aOrig = new int[a.length][];
+            for (int i=0; i<a.length; i++)
+                aOrig[i] = a[i].clone();
+            dftMethod.invoke(null, a, m, n);
+            idftMethod.invoke(null, a, m, n);
+            modFnMethod.invoke(null, new Object[] {a});
+            for (int j=0; j<aOrig.length; j++)
+                if (!Arrays.equals(a[j], aOrig[j]))
+                    failCount++;
+        }
+
+        // test multModFn
+        modFnMethod = BigInteger.class.getDeclaredMethod("modFn", int[].class);   // this is the other modFn method
+        modFnMethod.setAccessible(true);
+        Method multModFnMethod = BigInteger.class.getDeclaredMethod("multModFn", int[].class, int[].class);
+        multModFnMethod.setAccessible(true);
+        Constructor<BigInteger> ctor = BigInteger.class.getDeclaredConstructor(int.class, int[].class);
+        ctor.setAccessible(true);
+        for (int i=0; i<100; i++) {
+            int length = 1 << (1+rnd.nextInt(10));
+            int[] FnArr = new int[length];
+            FnArr[length/2-1] = 1;
+            FnArr[length-1] = 1;
+            BigInteger Fn = ctor.newInstance(1, FnArr);
+            int[] a = createRandomArray(length);
+            modFnMethod.invoke(null, new Object[] {a});
+            int[] b = createRandomArray(length);
+            modFnMethod.invoke(null, new Object[] {b});
+            int[] c = (int[])multModFnMethod.invoke(null, a, b);
+            modFnMethod.invoke(null, new Object[] {c});
+            BigInteger actual = ctor.newInstance(1, c);
+            BigInteger aBigInt = ctor.newInstance(1, a);
+            BigInteger bBigInt = ctor.newInstance(1, b);
+            BigInteger expected = aBigInt.multiply(bBigInt).mod(Fn);
+            if (!actual.equals(expected))
+                failCount++;
+        }
+
+        // test squareModFn
+        modFnMethod = BigInteger.class.getDeclaredMethod("modFn", int[].class);   // this is the other modFn method
+        modFnMethod.setAccessible(true);
+        Method squareModFnMethod = BigInteger.class.getDeclaredMethod("squareModFn", int[].class);
+        squareModFnMethod.setAccessible(true);
+        for (int i=0; i<100; i++) {
+            int length = 1 << (1+rnd.nextInt(10));
+            int[] FnArr = new int[length];
+            FnArr[length/2-1] = 1;
+            FnArr[length-1] = 1;
+            BigInteger Fn = ctor.newInstance(1, FnArr);
+            int[] a = createRandomArray(length);
+            modFnMethod.invoke(null, new Object[] {a});
+            int[] c = (int[])squareModFnMethod.invoke(null, a);
+            modFnMethod.invoke(null, new Object[] {c});
+            BigInteger actual = ctor.newInstance(1, c);
+            BigInteger aBigInt = ctor.newInstance(1, a);
+            BigInteger expected = (BigInteger)squareMethod.invoke(aBigInt);
+            expected = expected.mod(Fn);
+            if (!actual.equals(expected))
+                failCount++;
+        }
+
+        // test addModFn
+        Method addModFnMethod = BigInteger.class.getDeclaredMethod("addModFn", int[].class, int[].class);
+        addModFnMethod.setAccessible(true);
+        for (int k = 0; k<100; k++) {
+            int n = 5 + rnd.nextInt(10);
+            int len = 1 << (n + 1 - 5);
+            int[] aArr = createRandomArray(len);
+            aArr[0] &= 0x7FFFFFFF; // make sure the most significant int doesn't overflow
+            BigInteger a = ctor.newInstance(1, aArr);
+            int[] bArr = createRandomArray(len);
+            bArr[0] &= 0x7FFFFFFF; // make sure the most significant int doesn't overflow
+            BigInteger b = ctor.newInstance(1, bArr);
+            BigInteger Fn = BigInteger.valueOf(2).pow(1 << n).add(BigInteger.ONE);
+            BigInteger expected = a.add(b).mod(Fn);
+            addModFnMethod.invoke(null, aArr, bArr);
+            modFnMethod.invoke(null, aArr);
+            BigInteger actual = ctor.newInstance(1, aArr);
+            if (!actual.equals(expected))
+                failCount++;
+        }
+
+        // test subModFn
+        Method subModFnMethod = BigInteger.class.getDeclaredMethod("subModFn", int[].class, int[].class);
+        subModFnMethod.setAccessible(true);
+        for (int k = 0; k<100; k++) {
+            int n = 5 + rnd.nextInt(10);
+            int len = 1 << (n + 1 - 5);
+            int[] aArr = createRandomArray(len);
+            aArr[0] &= 0x7FFFFFFF; // make sure the most significant int doesn't overflow
+            BigInteger a = ctor.newInstance(1, aArr);
+            int[] bArr = createRandomArray(len);
+            bArr[0] &= 0x7FFFFFFF; // make sure the most significant int doesn't overflow
+            BigInteger b = ctor.newInstance(1, bArr);
+            BigInteger Fn = BigInteger.valueOf(2).pow(1 << n).add(BigInteger.ONE);
+            BigInteger expected = a.subtract(b).mod(Fn);
+            subModFnMethod.invoke(null, aArr, bArr);
+            modFnMethod.invoke(null, aArr);
+            BigInteger actual = ctor.newInstance(1, aArr);
+            if (!actual.equals(expected))
+                failCount++;
+        }
+
+        // test cyclicShiftLeftBits / cyclicShiftRightBits
+        Method shiftLeftMethod = BigInteger.class.getDeclaredMethod("cyclicShiftLeftBits", int[].class, int.class, int[].class);
+        shiftLeftMethod.setAccessible(true);
+        Method shiftRightMethod = BigInteger.class.getDeclaredMethod("cyclicShiftRightBits", int[].class, int.class, int[].class);
+        shiftRightMethod.setAccessible(true);
+        for (int k = 0; k<100; k++) {
+            int n = 1 << rnd.nextInt(20);
+            int[] a = createRandomArray(n);
+            int[] aOrig = a.clone();
+            // pick random shift amounts whose sum is zero
+            List<Integer> amounts = new ArrayList<Integer>();
+            int count = 1 + rnd.nextInt(20);
+            int total = 0;
+            for (int i = 0; i < count; i++) {
+                int amount = rnd.nextInt(n);
+                amounts.add(amount);
+                total += amount;
+            }
+            while (total > 0) {
+                int amount = Math.min(rnd.nextInt(n), total);
+                amounts.add(-amount);
+                total -= amount;
+            }
+            Collections.shuffle(amounts);
+            for (int amount : amounts) {
+                int[] b = new int[a.length];
+                if (amount > 0)
+                    shiftLeftMethod.invoke(null, a, amount, b);
+                else
+                    shiftRightMethod.invoke(null, a, -amount, b);
+                a = b;
+            }
+            if (!Arrays.equals(a, aOrig))
+                failCount++;
+        }
+
+        // test modFn
+        for (int k = 0; k<100; k++) {
+            int n = 5 + rnd.nextInt(15);
+            int len = 1 << (n + 1 - 5);
+            int[] a = createRandomArray(len);
+            int[] aOrig = a.clone();
+            modFnMethod.invoke(null, a);
+            BigInteger actual = ctor.newInstance(1, a);
+            BigInteger Fn = BigInteger.valueOf(2).pow(1 << n).add(BigInteger.ONE);
+            BigInteger expected = ctor.newInstance(1, aOrig).mod(Fn);
+            if (!actual.equals(expected))
+                failCount++;
+        }
+
+        // test addModPow2
+        Method addModPow2Method = BigInteger.class.getDeclaredMethod("addModPow2", int[].class, int[].class, int.class);
+        addModPow2Method.setAccessible(true);
+        for (int k = 0; k<100; k++) {
+            int n = 5 + rnd.nextInt(15);
+            int len = 1 << (n + 1 - 5);
+            int[] aArr = createRandomArray(len);
+            aArr[0] &= 0x7FFFFFFF; // make sure the most significant int doesn't overflow
+            BigInteger a = ctor.newInstance(1, aArr);
+            int[] bArr = createRandomArray(len);
+            bArr[0] &= 0x7FFFFFFF; // make sure the most significant int doesn't overflow
+            BigInteger b = ctor.newInstance(1, bArr);
+            int numBits = rnd.nextInt(n);
+            BigInteger pow2 = BigInteger.valueOf(1<<numBits);
+            BigInteger expected = a.add(b).mod(pow2);
+            addModPow2Method.invoke(null, aArr, bArr, numBits);
+            BigInteger actual = ctor.newInstance(1, aArr);
+            if (!actual.equals(expected))
+                failCount++;
+        }
+
+        // test subModPow2
+        Method subModPow2Method = BigInteger.class.getDeclaredMethod("subModPow2", int[].class, int[].class, int.class);
+        subModPow2Method.setAccessible(true);
+        for (int k = 0; k<100; k++) {
+            int n = 5 + rnd.nextInt(15);
+            int len = 1 << (n + 1 - 5);
+            int[] aArr = createRandomArray(len);
+            aArr[0] &= 0x7FFFFFFF; // make sure the most significant int doesn't overflow
+            BigInteger a = ctor.newInstance(1, aArr);
+            int[] bArr = createRandomArray(len);
+            bArr[0] &= 0x7FFFFFFF; // make sure the most significant int doesn't overflow
+            BigInteger b = ctor.newInstance(1, bArr);
+            int numBits = rnd.nextInt(n);
+            BigInteger pow2 = BigInteger.valueOf(1<<numBits);
+            BigInteger expected = a.subtract(b).mod(pow2);
+            subModPow2Method.invoke(null, aArr, bArr, numBits);
+            BigInteger actual = ctor.newInstance(1, aArr);
+            if (!actual.equals(expected))
+                failCount++;
+        }
+
+        // test splitBits
+        Method splitBitsMethod = BigInteger.class.getDeclaredMethod("splitBits", int[].class, int.class);
+        splitBitsMethod.setAccessible(true);
+        for (int k = 0; k<100; k++) {
+            int n = 1 + rnd.nextInt(1000);
+            int[] aArr = createRandomArray(n);
+            BigInteger actual = ctor.newInstance(1, aArr);
+            int pieceSize = 1 + smallRandom(n-1, rnd);
+            int[][] pieces = (int[][])splitBitsMethod.invoke(null, aArr, pieceSize);
+            BigInteger expected = ZERO;
+            for (int i=pieces.length-1; i>=0; i--) {
+                int[] piece = pieces[i];
+                BigInteger pieceBigInt = ctor.newInstance(1, piece);
+                expected = expected.shiftLeft(pieceSize).add(pieceBigInt);
+            }
+            if (!actual.equals(expected))
+                failCount++;
+        }
+
+        // test addShifted
+        Method addShiftedMethod = BigInteger.class.getDeclaredMethod("addShifted", int[].class, int[].class, int.class);
+        addShiftedMethod.setAccessible(true);
+        for (int k = 0; k<100; k++) {
+            int[] aArr = createRandomArray(1 + rnd.nextInt(1000));
+            BigInteger a = ctor.newInstance(1, aArr);
+            int offset = rnd.nextInt(aArr.length);
+            int[] bArr = createRandomArray(1 + rnd.nextInt(1000));
+            BigInteger b = ctor.newInstance(1, bArr);
+            addShiftedMethod.invoke(null, aArr, bArr, offset);
+            BigInteger actual = ctor.newInstance(1, aArr);
+            BigInteger mask = ONE.shiftLeft(aArr.length*32).subtract(ONE);
+            BigInteger expected = a.add(b.shiftLeft(offset*32)).and(mask);
+            if (!actual.equals(expected))
+                failCount++;
+        }
+        
+        // test appendBits
+//        Method appendBitsMethod = BigInteger.class.getDeclaredMethod("appendBits", int[].class, int.class, int[].class, int.class, int.class);
+//        appendBitsMethod.setAccessible(true);
+//rnd=new Random(2);
+//        for (int k = 0; k < 100; k++) {
+//            int[] src = createRandomArray(1 + rnd.nextInt(1000));
+//src=createRandomArray(2);
+//            BigInteger srcBigInt = ctor.newInstance(1, src);
+//            int[] dest = new int[src.length];
+//            int valBits = 1 + smallRandom(src.length*32-1, rnd);
+//            int padBits = 1 + smallRandom(src.length*32-1, rnd);
+////if(k<95)continue;
+//            BigInteger mask = ONE.shiftLeft(valBits).subtract(ONE);
+//            int srcIndex = 0;
+//            int destBits = 0;
+//            BigInteger expected = ZERO;
+//            while (srcIndex+(valBits+31)/32<src.length && destBits+valBits+padBits<dest.length*32) {
+//                expected = expected.add(srcBigInt.shiftRight(srcIndex*32).and(mask).shiftLeft(destBits));
+//                appendBitsMethod.invoke(null, dest, destBits, src, srcIndex, valBits);
+//                srcIndex += (valBits+31) / 32;
+//                destBits += valBits + padBits;
+//            }
+//            BigInteger actual = ctor.newInstance(1, dest);
+//            if (!actual.equals(expected))
+//                failCount++;
+//        }
+
+        report("Schoenhage-Strassen", failCount);
+    }
+
+    // like Random.nextInt(int) but favors small numbers
+    private static int smallRandom(int n, Random rnd) {
+        return (int)(n * Math.pow(rnd.nextDouble(), 5));
+    }
+
+    private static int[] createRandomArray(int length) {
+        Random rnd = new Random();
+        int[] a = new int[length];
+        for (int i=0; i<a.length; i++)
+            a[i] = rnd.nextInt();
+        return a;
+    }
+
+    private static int[][] createRandomDftArray(int m, int n) {
+        Random rnd = new Random();
+        int numElements = m%2==0 ? 1<<n : 1<<(n+1);
+        numElements /= 2;
+        int[][] a = new int[numElements][1<<(n+1-5)];
+        for (int i=0; i<a.length; i++)
+            for (int j=0; j<a[i].length; j++)
+                a[i][j] = rnd.nextInt();
+        return a;
+    }
+
+    public static void square(int order) {
+        int failCount = 0;
+
+        int iterations = order<100000 ? size : reducedSize;
+        for (int i=0; i<iterations; i++) {
+            BigInteger x = fetchNumber(order);
+
+            try {
+                Method squareMethod = BigInteger.class.getDeclaredMethod("square");
+                squareMethod.setAccessible(true);
+                BigInteger square = (BigInteger)squareMethod.invoke(x);
+                BigInteger expected = x.multiply(x);
+
+                if (!square.equals(expected)) {
+                    failCount++;
+                }
+            } catch (Exception e) {
+                e.printStackTrace();
+                failCount++;
+            }
+        }
+
+        report("Square for " + order + " bits", failCount);
     }
 
     public static void bitCount() {
@@ -160,11 +525,11 @@
         report("BitLength", failCount);
     }
 
-    public static void bitOps() {
+    public static void bitOps(int order) {
         int failCount1 = 0, failCount2 = 0, failCount3 = 0;
 
         for (int i=0; i<size*5; i++) {
-            BigInteger x = fetchNumber(order1);
+            BigInteger x = fetchNumber(order);
             BigInteger y;
 
             /* Test setBit and clearBit (and testBit) */
@@ -194,7 +559,7 @@
         report("flipBit/testBit", failCount2);
 
         for (int i=0; i<size*5; i++) {
-            BigInteger x = fetchNumber(order1);
+            BigInteger x = fetchNumber(order);
 
             /* Test getLowestSetBit() */
             int k = x.getLowestSetBit();
@@ -213,13 +578,13 @@
         report("getLowestSetBit", failCount3);
     }
 
-    public static void bitwise() {
+    public static void bitwise(int order) {
 
         /* Test identity x^y == x|y &~ x&y */
         int failCount = 0;
         for (int i=0; i<size; i++) {
-            BigInteger x = fetchNumber(order1);
-            BigInteger y = fetchNumber(order1);
+            BigInteger x = fetchNumber(order);
+            BigInteger y = fetchNumber(order);
             BigInteger z = x.xor(y);
             BigInteger w = x.or(y).andNot(x.and(y));
             if (!z.equals(w))
@@ -230,8 +595,8 @@
         /* Test identity x &~ y == ~(~x | y) */
         failCount = 0;
         for (int i=0; i<size; i++) {
-            BigInteger x = fetchNumber(order1);
-            BigInteger y = fetchNumber(order1);
+            BigInteger x = fetchNumber(order);
+            BigInteger y = fetchNumber(order);
             BigInteger z = x.andNot(y);
             BigInteger w = x.not().or(y).not();
             if (!z.equals(w))
@@ -240,13 +605,13 @@
         report("Logic (&~ | ~)", failCount);
     }
 
-    public static void shift() {
+    public static void shift(int order) {
         int failCount1 = 0;
         int failCount2 = 0;
         int failCount3 = 0;
 
         for (int i=0; i<100; i++) {
-            BigInteger x = fetchNumber(order1);
+            BigInteger x = fetchNumber(order);
             int n = Math.abs(rnd.nextInt()%200);
 
             if (!x.shiftLeft(n).equals
@@ -279,13 +644,14 @@
         report("baz shiftLeft/Right", failCount3);
     }
 
-    public static void divideAndRemainder() {
+    public static void divideAndRemainder(int order) {
         int failCount1 = 0;
 
-        for (int i=0; i<size; i++) {
-            BigInteger x = fetchNumber(order1).abs();
+        int iterations = order<100000 ? size : reducedSize;
+        for (int i=0; i<iterations; i++) {
+            BigInteger x = fetchNumber(order).abs();
             while(x.compareTo(BigInteger.valueOf(3L)) != 1)
-                x = fetchNumber(order1).abs();
+                x = fetchNumber(order).abs();
             BigInteger z = x.divide(BigInteger.valueOf(2L));
             BigInteger y[] = x.divideAndRemainder(x);
             if (!y[0].equals(BigInteger.ONE)) {
@@ -306,7 +672,7 @@
                 System.err.println("      y :"+y);
             }
         }
-        report("divideAndRemainder I", failCount1);
+        report("divideAndRemainder for " + order + " bits", failCount1);
     }
 
     public static void stringConv() {
@@ -331,13 +697,13 @@
         report("String Conversion", failCount);
     }
 
-    public static void byteArrayConv() {
+    public static void byteArrayConv(int order) {
         int failCount = 0;
 
         for (int i=0; i<size; i++) {
-            BigInteger x = fetchNumber(order1);
+            BigInteger x = fetchNumber(order);
             while (x.equals(BigInteger.ZERO))
-                x = fetchNumber(order1);
+                x = fetchNumber(order);
             BigInteger y = new BigInteger(x.toByteArray());
             if (!x.equals(y)) {
                 failCount++;
@@ -348,16 +714,17 @@
         report("Array Conversion", failCount);
     }
 
-    public static void modInv() {
+    public static void modInv(int order) {
         int failCount = 0, successCount = 0, nonInvCount = 0;
 
-        for (int i=0; i<size; i++) {
-            BigInteger x = fetchNumber(order1);
+        int iterations = order<100000 ? size : reducedSize;
+        for (int i=0; i<iterations; i++) {
+            BigInteger x = fetchNumber(order);
             while(x.equals(BigInteger.ZERO))
-                x = fetchNumber(order1);
-            BigInteger m = fetchNumber(order1).abs();
+                x = fetchNumber(order);
+            BigInteger m = fetchNumber(order).abs();
             while(m.compareTo(BigInteger.ONE) != 1)
-                m = fetchNumber(order1).abs();
+                m = fetchNumber(order).abs();
 
             try {
                 BigInteger inv = x.modInverse(m);
@@ -374,10 +741,10 @@
                 nonInvCount++;
             }
         }
-        report("Modular Inverse", failCount);
+        report("Modular Inverse for " + order + " bits", failCount);
     }
 
-    public static void modExp() {
+    public static void modExp(int order1, int order2) {
         int failCount = 0;
 
         for (int i=0; i<size/10; i++) {
@@ -404,7 +771,7 @@
     // This test is based on Fermat's theorem
     // which is not ideal because base must not be multiple of modulus
     // and modulus must be a prime or pseudoprime (Carmichael number)
-    public static void modExp2() {
+    public static void modExp2(int order) {
         int failCount = 0;
 
         for (int i=0; i<10; i++) {
@@ -412,11 +779,11 @@
             while(m.compareTo(BigInteger.ONE) != 1)
                 m = new BigInteger(100, 5, rnd);
             BigInteger exp = m.subtract(BigInteger.ONE);
-            BigInteger base = fetchNumber(order1).abs();
+            BigInteger base = fetchNumber(order).abs();
             while(base.compareTo(m) != -1)
-                base = fetchNumber(order1).abs();
+                base = fetchNumber(order).abs();
             while(base.equals(BigInteger.ZERO))
-                base = fetchNumber(order1).abs();
+                base = fetchNumber(order).abs();
 
             BigInteger one = base.modPow(exp, m);
             if (!one.equals(BigInteger.ONE)) {
@@ -703,6 +1070,12 @@
      *
      */
     public static void main(String[] args) throws Exception {
+        // Some variables for sizing test numbers in bits
+        int order1 = 100;
+        int order2 = 60;
+        int order3 = 3600;   // #bits for testing Karatsuba and Burnikel-Ziegler
+        int order4 = 6000;   // #bits for testing Toom-Cook
+        int order5 = 3500000; // #bits for testing Schoenhage-Strassen and Barrett
 
         if (args.length >0)
             order1 = (int)((Integer.parseInt(args[0]))* 3.333);
@@ -710,26 +1083,48 @@
             order2 = (int)((Integer.parseInt(args[1]))* 3.333);
         if (args.length >2)
             order3 = (int)((Integer.parseInt(args[2]))* 3.333);
+        if (args.length >3)
+            order4 = (int)((Integer.parseInt(args[3]))* 3.333);
+        if (args.length >4)
+            order5 = (int)((Integer.parseInt(args[4]))* 3.333);
 
         prime();
         nextProbablePrime();
 
-        arithmetic();
-        divideAndRemainder();
-        pow();
+        schoenhageStrassen(order5);
+
+        square(order1);   // small numbers
+        square(order3);   // Karatsuba / Burnikel-Ziegler range
+        square(order4);   // Toom-Cook range
+        square(order5);   // SS/Barrett range
+
+        arithmetic(order1);   // small numbers
+        arithmetic(order3);   // Karatsuba / Burnikel-Ziegler range
+        arithmetic(order4);   // Toom-Cook range
+        arithmetic(order5);   // SS/Barrett range
+
+        divideAndRemainder(order1);   // small numbers
+        divideAndRemainder(order3);   // Karatsuba / Burnikel-Ziegler range
+        divideAndRemainder(order4);   // Toom-Cook range
+        divideAndRemainder(order5);   // SS/Barrett range
+
+        pow(order1);
 
         bitCount();
         bitLength();
-        bitOps();
-        bitwise();
+        bitOps(order1);
+        bitwise(order1);
+
+        shift(order1);
 
-        shift();
+        byteArrayConv(order1);
 
-        byteArrayConv();
+        modInv(order1);   // small numbers
+        modInv(order3);   // Karatsuba / Burnikel-Ziegler range
+        modInv(order4);   // Toom-Cook range
 
-        modInv();
-        modExp();
-        modExp2();
+        modExp(order1, order2);
+        modExp2(order1);
 
         stringConv();
         serialize();
@@ -747,7 +1142,7 @@
      */
     private static BigInteger fetchNumber(int order) {
         boolean negative = rnd.nextBoolean();
-        int numType = rnd.nextInt(6);
+        int numType = rnd.nextInt(7);
         BigInteger result = null;
         if (order < 2) order = 2;
 
@@ -775,12 +1170,25 @@
                 break;
 
             case 4: // Random bit density
-                int iterations = rnd.nextInt(order-1);
-                result = BigInteger.ONE.shiftLeft(rnd.nextInt(order));
-                for(int i=0; i<iterations; i++) {
-                    BigInteger temp = BigInteger.ONE.shiftLeft(
-                                                rnd.nextInt(order));
-                    result = result.or(temp);
+                byte[] val = new byte[(order+7)/8];
+                int iterations = rnd.nextInt(order);
+                for (int i=0; i<iterations; i++) {
+                    int bitIdx = rnd.nextInt(order);
+                    val[bitIdx/8] |= 1 << (bitIdx%8);
+                }
+                result = new BigInteger(1, val);
+                break;
+            case 5: // Runs of consecutive ones and zeros
+                result = ZERO;
+                int remaining = order;
+                int bit = rnd.nextInt(2);
+                while (remaining > 0) {
+                    int runLength = Math.min(remaining, rnd.nextInt(order));
+                    result = result.shiftLeft(runLength);
+                    if (bit > 0)
+                        result = result.add(ONE.shiftLeft(runLength).subtract(ONE));
+                    remaining -= runLength;
+                    bit = 1 - bit;
                 }
                 break;
 
