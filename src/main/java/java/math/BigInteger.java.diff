--- ../jdk8/jdk/src/share/classes/java/math/BigInteger.java	2013-12-16 19:30:55.222190028 +0100
+++ src/main/java/java/math/BigInteger.java	2013-12-19 10:53:32.520082203 +0100
@@ -218 +218 @@
-    private static final int KARATSUBA_THRESHOLD = 80;
+    private static final int KARATSUBA_THRESHOLD = 50;
@@ -227 +227 @@
-    private static final int TOOM_COOK_THRESHOLD = 240;
+    private static final int TOOM_COOK_THRESHOLD = 75;
@@ -235 +235 @@
-    private static final int KARATSUBA_SQUARE_THRESHOLD = 128;
+    private static final int KARATSUBA_SQUARE_THRESHOLD = 90;
@@ -243 +243 @@
-    private static final int TOOM_COOK_SQUARE_THRESHOLD = 216;
+    private static final int TOOM_COOK_SQUARE_THRESHOLD = 140;
@@ -250 +250 @@
-    static final int BURNIKEL_ZIEGLER_THRESHOLD = 80;
+    static final int BURNIKEL_ZIEGLER_THRESHOLD = 50;
@@ -261,0 +262,6 @@
+     * The threshold value, in bits, for using Newton iteration when
+     * computing the reciprocal of a number.
+     */
+    private static final int NEWTON_THRESHOLD = 100;
+
+    /**
@@ -269 +275,6 @@
-    private static final int SCHOENHAGE_BASE_CONVERSION_THRESHOLD = 20;
+    private static final int SCHOENHAGE_BASE_CONVERSION_THRESHOLD = 8;
+
+    /**
+     * Whether we're running on a 64-bit JVM.
+     */
+    private static final boolean IS64BIT = "64".equals(System.getProperty("sun.arch.data.model"));
@@ -1486 +1497 @@
-            } else {
+            } else if (!shouldMultiplySchoenhageStrassen(xlen) || !shouldMultiplySchoenhageStrassen(ylen)) {
@@ -1487,0 +1499,2 @@
+            } else {
+                return multiplySchoenhageStrassen(this, val);
@@ -1853,0 +1867,1108 @@
+    // Schoenhage-Strassen
+
+    /**
+     * Multiplies two {@link BigInteger}s using the
+     * <a href="http://en.wikipedia.org/wiki/Sch%C3%B6nhage%E2%80%93Strassen_algorithm">
+     * Schoenhage-Strassen algorithm</a> algorithm.
+     * @param a
+     * @param b
+     * @return a <code>BigInteger</code> equal to <code>a.multiply(b)</code>
+     */
+    private static BigInteger multiplySchoenhageStrassen(BigInteger a, BigInteger b) {
+        // remove any minus signs, multiply, then fix sign
+        int signum = a.signum() * b.signum();
+        if (a.signum() < 0)
+            a = a.negate();
+        if (b.signum() < 0)
+            b = b.negate();
+
+        int[] cArr = multiplySchoenhageStrassen(a.mag, b.mag);
+
+        BigInteger c = new BigInteger(1, cArr);
+        if (signum < 0)
+            c = c.negate();
+
+        return c;
+    }
+
+    /**
+     * Squares this number using the
+     * <a href="http://en.wikipedia.org/wiki/Sch%C3%B6nhage%E2%80%93Strassen_algorithm">
+     * Schoenhage-Strassen algorithm</a>.
+     * @return a <code>BigInteger</code> equal to <code>this.multiply(this)</code>
+     */
+    private BigInteger squareSchoenhageStrassen() {
+        // remove any minus sign
+        int[] aArr = signum()>=0 ? mag : negate().mag;
+
+        int[] cArr = squareSchoenhageStrassen(aArr);
+        BigInteger c = new BigInteger(1, cArr);
+
+        return c;
+    }
+
+    /**
+     * This is the core Schoenhage-Strassen method. It multiplies two <b>positive</b> numbers of length
+     * <code>aBitLen</code> and </code>bBitLen</code> that are represented as int arrays, i.e. in base
+     * 2<sup>32</sup>.
+     * Positive means an int is always interpreted as an unsigned number, regardless of the sign bit.<br/>
+     * The arrays must be ordered most significant to least significant, so the most significant digit
+     * must be at index 0.
+     * <p/>
+     * The Schoenhage-Strassen algorithm algorithm works as follows:
+     * <ol>
+     *   <li>Given numbers a and b, split both numbers into pieces of length 2<sup>n-1</sup> bits.
+     *       See the code for how n is calculated.</li>
+     *   <li>Take the low n+2 bits of each piece of a, zero-pad them to 3n+5 bits,
+     *       and concatenate them to a new number u.</li>
+     *   <li>Do the same for b to obtain v.</li>
+     *   <li>Calculate all pieces of gamma by multiplying u and v (using Schoenhage-Strassen or another
+     *       algorithm).</li>
+     *   <li>Split gamma into pieces of 3n+5 bits.</li>
+     *   <li>Calculate z'<sub>i</sub> = gamma<sub>i</sub> + gamma<sub>i+2*2<sup>n</sup></sub> -
+     *       gamma<sub>i+2<sup>n</sup></sub> - gamma<sub>i+3*2<sup>n</sup></sub> and reduce modulo
+     *       2<sup>n+2</sup>.<br/>
+     *       z'<sub>i</sub> will be the i-th piece of a*b mod 2<sup>n+2</sup>.</li>
+     *   <li>Pad the pieces of a and b from step 1 to 2<sup>n+1</sup> bits.</li>
+     *   <li>Perform a
+     *       <a href="http://en.wikipedia.org/wiki/Discrete_Fourier_transform_%28general%29#Number-theoretic_transform">
+     *       Discrete Fourier Transform</a> (DFT) on the padded pieces.</li>
+     *   <li>Calculate all pieces of z" by multiplying the i-th piece of a by the i-th piece of b.</li>
+     *   <li>Perform an Inverse Discrete Fourier Transform (IDFT) on z". z" will contain all pieces of
+     *       a*b mod F<sub>n</sub> where F<sub>n</sub>=2<sup>2<sup>n</sup></sup>+1.</li>
+     *   <li>Calculate all pieces of z such that each piece is congruent to z' modulo n+2 and congruent to
+     *       z" modulo F<sub>n</sub>. This is done using the
+     *       <a href="http://en.wikipedia.org/wiki/Chinese_remainder_theorem">Chinese remainder theorem</a>.</li>
+     *   <li>Calculate c by adding z<sub>i</sub> * 2<sup>i*2<sup>n-1</sup></sup> for all i, where z<sub>i</sub> is the
+     *       i-th piece of z.</li>
+     *   <li>Return c reduced modulo 2<sup>2<sup>m</sup></sup>+1. See the code for how m is calculated.</li>
+     * </ol>
+     *
+     * References:
+     * <ol>
+     *   <li><a href="http://en.wikipedia.org/wiki/Sch%C3%B6nhage%E2%80%93Strassen_algorithm">
+     *       Wikipedia article</a>
+     *   <li><a href="http://www.scribd.com/doc/68857222/Schnelle-Multiplikation-gro%C3%9Fer-Zahlen">
+     *       Arnold Schoenhage und Volker Strassen: Schnelle Multiplikation grosser Zahlen, Computing 7, 1971,
+     *       Springer-Verlag, S. 281-292</a></li>
+     *   <li><a href="http://malte-leip.net/beschreibung_ssa.pdf">Eine verstaendliche Beschreibung des
+     *       Schoenhage-Strassen-Algorithmus</a></li>
+     * </ol>
+     * @param a
+     * @param b
+     * @return a*b
+     */
+    private static int[] multiplySchoenhageStrassen(int[] a, int[] b) {
+        // set M to the number of binary digits in a or b, whichever is greater
+        int M = Math.max(a.length*32, b.length*32);
+
+        // find the lowest m such that m>=log2(2M)
+        int m = 32 - Integer.numberOfLeadingZeros(2*M-1-1);
+
+        int n = m/2 + 1;
+
+        // split a and b into pieces 1<<(n-1) bits long; assume n>=6 so pieces start and end at int boundaries
+        boolean even = m%2 == 0;
+        int numPieces = even ? 1<<n : 1<<(n+1);
+        int pieceSize = 1 << (n-1-5);   // in ints
+
+        // build u and v from a and b, allocating 3n+5 bits in u and v per n+2 bits from a and b, resp.
+        int numPiecesA = (a.length+pieceSize) / pieceSize;
+        int[] u = new int[(numPiecesA*(3*n+5)+31)/32];
+        int uBitLength = 0;
+        for (int i=0; i<numPiecesA && i*pieceSize<a.length; i++) {
+            appendBits(u, uBitLength, a, i*pieceSize, n+2);
+            uBitLength += 3*n+5;
+        }
+        int numPiecesB = (b.length+pieceSize) / pieceSize;
+        int[] v = new int[(numPiecesB*(3*n+5)+31)/32];
+        int vBitLength = 0;
+        for (int i=0; i<numPiecesB && i*pieceSize<b.length; i++) {
+            appendBits(v, vBitLength, b, i*pieceSize, n+2);
+            vBitLength += 3*n+5;
+        }
+
+        int[] gamma = new BigInteger(1, u).multiply(new BigInteger(1, v)).mag;   // gamma = u * v
+        int[][] gammai = splitBits(gamma, 3*n+5);
+        int halfNumPcs = numPieces / 2;
+
+        int[][] zi = new int[gammai.length][];
+        for (int i=0; i<gammai.length; i++)
+            zi[i] = gammai[i];
+        for (int i=0; i<gammai.length-halfNumPcs; i++)
+            subModPow2(zi[i], gammai[i+halfNumPcs], n+2);
+        for (int i=0; i<gammai.length-2*halfNumPcs; i++)
+            addModPow2(zi[i], gammai[i+2*halfNumPcs], n+2);
+        for (int i=0; i<gammai.length-3*halfNumPcs; i++)
+            subModPow2(zi[i], gammai[i+3*halfNumPcs], n+2);
+
+        // zr mod Fn
+        int[][] ai = splitInts(a, halfNumPcs, pieceSize, 1<<(n+1-5));
+        int[][] bi = splitInts(b, halfNumPcs, pieceSize, 1<<(n+1-5));
+        int omega = even ? 4 : 2;
+        dft(ai, omega);
+        dft(bi, omega);
+        modFn(ai);
+        modFn(bi);
+        int[][] c = new int[halfNumPcs][];
+        for (int i=0; i<c.length; i++)
+            c[i] = multModFn(ai[i], bi[i]);
+        idft(c, omega);
+        modFn(c);
+
+        int[] z = new int[1<<(m+1-5)];
+        // calculate zr mod Fm from zr mod Fn and zr mod 2^(n+2), then add to z
+        for (int i=0; i<halfNumPcs; i++) {
+            int[] eta = i>=zi.length ? new int[(n+2+31)/32] : zi[i];
+
+            // zi = delta = (zi-c[i]) % 2^(n+2)
+            subModPow2(eta, c[i], n+2);
+
+            // z += zr<<shift = [ci + delta*(2^2^n+1)] << [i*2^(n-1)]
+            int shift = i*(1<<(n-1-5));   // assume n>=6
+            addShifted(z, c[i], shift);
+            addShifted(z, eta, shift);
+            addShifted(z, eta, shift+(1<<(n-5)));
+        }
+
+        modFn(z);   // assume m>=5
+        return z;
+    }
+
+    /**
+     * Squares a <b>positive</b> number of length <code>aBitLen</code> that is represented as an int
+     * array, i.e. in base 2<sup>32</sup>.
+     * @param a
+     * @return a<sup>2</sup>
+     * @see #multiplySchoenhageStrassen(int[], int, int[], int)
+     */
+    private int[] squareSchoenhageStrassen(int[] a) {
+        // set M to the number of binary digits in a
+        int M = a.length * 32;
+
+        // find the lowest m such that m>=log2(2M)
+        int m = 32 - Integer.numberOfLeadingZeros(2*M-1-1);
+
+        int n = m/2 + 1;
+
+        // split a into pieces 1<<(n-1) bits long; assume n>=6 so pieces start and end at int boundaries
+        boolean even = m%2 == 0;
+        int numPieces = even ? 1<<n : 1<<(n+1);
+        int pieceSize = 1 << (n-1-5);   // in ints
+
+        // build u from a, allocating 3n+5 bits in u per n+2 bits from a
+        int numPiecesA = (a.length+pieceSize) / pieceSize;
+        int[] u = new int[(numPiecesA*(3*n+5)+31)/32];
+        int uBitLength = 0;
+        for (int i=0; i<numPiecesA && i*pieceSize<a.length; i++) {
+            appendBits(u, uBitLength, a, i*pieceSize, n+2);
+            uBitLength += 3*n+5;
+        }
+
+        int[] gamma = new BigInteger(1, u).square().mag;   // gamma = u * u
+
+        int[][] gammai = splitBits(gamma, 3*n+5);
+        int halfNumPcs = numPieces / 2;
+
+        int[][] zi = new int[gammai.length][];
+        for (int i=0; i<gammai.length; i++)
+            zi[i] = gammai[i];
+        for (int i=0; i<gammai.length-halfNumPcs; i++)
+            subModPow2(zi[i], gammai[i+halfNumPcs], n+2);
+        for (int i=0; i<gammai.length-2*halfNumPcs; i++)
+            addModPow2(zi[i], gammai[i+2*halfNumPcs], n+2);
+        for (int i=0; i<gammai.length-3*halfNumPcs; i++)
+            subModPow2(zi[i], gammai[i+3*halfNumPcs], n+2);
+
+        // zr mod Fn
+        int[][] ai = splitInts(a, halfNumPcs, pieceSize, 1<<(n+1-5));
+        int omega = even ? 4 : 2;
+        dft(ai, omega);
+        modFn(ai);
+        int[][] c = new int[halfNumPcs][];
+        for (int i=0; i<c.length; i++)
+            c[i] = squareModFn(ai[i]);
+        idft(c, omega);
+        modFn(c);
+
+        int[] z = new int[1<<(m+1-5)];
+        // calculate zr mod Fm from zr mod Fn and zr mod 2^(n+2), then add to z
+        for (int i=0; i<halfNumPcs; i++) {
+            int[] eta = i>=zi.length ? new int[(n+2+31)/32] : zi[i];
+
+            // zi = delta = (zi-c[i]) % 2^(n+2)
+            subModPow2(eta, c[i], n+2);
+
+            // z += zr<<shift = [ci + delta*(2^2^n+1)] << [i*2^(n-1)]
+            int shift = i*(1<<(n-1-5));   // assume n>=6
+            addShifted(z, c[i], shift);
+            addShifted(z, eta, shift);
+            addShifted(z, eta, shift+(1<<(n-5)));
+        }
+
+        modFn(z);   // assume m>=5
+        return z;
+    }
+
+    /**
+     * Estimates whether SS will be more efficient than the other methods when multiplying two numbers
+     * of a given length in bits.
+     * @param length the number of ints in each of the two factors
+     * @return <code>true</code> if SS is more efficient, <code>false</code> if Toom-Cook is more efficient
+     */
+    private boolean shouldMultiplySchoenhageStrassen(int length) {
+        if (IS64BIT) {
+            // The following values were determined experimentally on a 64-bit JVM.
+            // SS is slower than Toom-Cook below ~15,500 ints (~149,000 decimal digits)
+            // and faster above ~73,200 ints (~705,000 decimal digits).
+            // Between those values, it changes several times.
+            if (length <= 15500)
+                return false;
+            if (length <= 16384)   // 2^14
+                return true;
+            if (length <= 26300)
+                return false;
+            if (length <= 32768)   // 2^15
+                return true;
+            if (length <= 44000)
+                return false;
+            if (length <= 65536)   // 2^16
+                return true;
+            if (length <= 73200)
+                return false;
+            return true;
+        } else {
+            // The following values were determined experimentally on a 32-bit JVM.
+            // SS is slower than Toom-Cook below ~6,300 ints (~60,700 decimal digits)
+            // and faster above ~34,000 ints (~327,500 decimal digits).
+            // Between those values, it changes several times.
+            if (length <= 6300)
+                return false;
+            if (length <= 16384)   // 2^14
+                return true;
+            if (length <= 19300)
+                return false;
+            if (length <= 32768)   // 2^15
+                return true;
+            if (length <= 34000)
+                return false;
+            return true;
+        }
+    }
+
+    /**
+     * Estimates whether SS will be more efficient than the other methods when squaring a number
+     * of a given length in bits.
+     * @param bitLength the number of ints in the number to be squared
+     * @return <code>true</code> if SS is more efficient, <code>false</code> if Toom-Cook is more efficient
+     * @see #shouldMultiplySchoenhageStrassen(int)
+     */
+    private boolean shouldSquareSchoenhageStrassen(int length) {
+        if (IS64BIT) {
+            if (length <= 15000)
+                return false;
+            if (length <= 16384)   // 2^14
+                return true;
+            if (length <= 27100)
+                return false;
+            if (length <= 32768)   // 2^15
+                return true;
+            if (length <= 43600)
+                return false;
+            if (length <= 65536)   // 2^16
+                return true;
+            if (length <= 76300)
+                return false;
+            if (length <= 131072)   // 2^17
+                return true;
+            if (length <= 133800)
+                return false;
+            return true;
+        } else {
+            if (length <= 7100)
+                return false;
+            if (length <= 8192)   // 2^13
+                return true;
+            if (length <= 14200)
+                return false;
+            if (length <= 16384)   // 2^14
+                return true;
+            if (length <= 24100)
+                return false;
+            if (length <= 32768)   // 2^15
+                return true;
+            if (length <= 42800)
+                return false;
+            if (length <= 65536)   // 2^16
+                return true;
+            if (length <= 73000)
+                return false;
+            return true;
+        }
+    }
+
+    /**
+     * Performs a modified
+     * <a href="http://en.wikipedia.org/wiki/Discrete_Fourier_transform_%28general%29#Number-theoretic_transform">
+     * Fermat Number Transform</a> on an array whose elements are <code>int</code> arrays.<br/>
+     * The modification is that the first step is omitted because only the upper half of the result is needed.<br/>
+     * This implementation uses <a href="http://www.nas.nasa.gov/assets/pdf/techreports/1989/rnr-89-004.pdf">
+     * Bailey's 4-step algorithm</a>.<br/>
+     * <code>A</code> is assumed to be the lower half of the full array and the upper half is assumed to be all zeros.
+     * The number of subarrays in <code>A</code> must be 2<sup>n</sup> if m is even and 2<sup>n+1</sup> if m is odd.<br/>
+     * Each subarray must be ceil(2<sup>n-1</sup>) bits in length.<br/>
+     * n must be equal to m/2-1.
+     * @param A
+     * @param omega 2 or 4
+     */
+    private static void dft(int[][] A, int omega) {
+        // arrange the elements of A in a matrix roughly sqrt(A.length) by sqrt(A.length) in size
+        int rows = 1 << ((31-Integer.numberOfLeadingZeros(A.length))/2);   // number of rows
+        int cols = A.length / rows;   // number of columns
+
+        // step 1: perform an DFT on each column
+        for (int i=0; i<cols; i++)
+            dftBailey1(A, omega, rows, cols, i);
+
+        // step 2: multiply by powers of omega
+        applyDftWeights(A, omega, rows, cols);
+
+        // step 3 is built into step 1 by making the stride length a multiple of the row length
+
+        // step 4: perform an DFT on each row
+        for (int i=0; i<rows; i++)
+            dftBailey2(A, omega, rows, cols, i);
+    }
+
+    /**
+     * Performs an DFT on column {@code colIdx}.<br/>
+     * <code>A</code> is assumed to be the lower half of the full array.
+     * @param A an array of length rows*cols
+     * @param omega root of unity
+     * @param rows number of rows in A
+     * @param cols number of columns in A
+     * @param colIdx index of the column to transform
+     */
+    private static void dftBailey1(int[][] A, int omega, int rows, int cols, int colIdx) {
+        dftDirect(A, omega, rows, cols, rows, colIdx, cols);
+    }
+
+    /**
+     * Performs an DFT on row {@code rowIdx}.<br/>
+     * <code>A</code> is assumed to be the lower half of the full array.
+     * @param A an array of length rows*cols
+     * @param omega root of unity
+     * @param rows number of rows in A
+     * @param cols number of columns in A
+     * @param rowIdx index of the row to transform
+     */
+    private static void dftBailey2(int[][] A, int omega, int rows, int cols, int rowIdx) {
+        dftDirect(A, omega, 0, rows, cols, rowIdx*cols, 1);
+    }
+
+    /** This implementation uses the radix-4 technique which combines two levels of butterflies. */
+    private static void dftDirect(int[][] A, int omega, int expOffset, int expScale, int len, int idxOffset, int stride) {
+        int n = 31 - Integer.numberOfLeadingZeros(2*len);   // multiply by 2 because we're doing a half DFT and we need the n that corresponds to the full DFT length
+        int v = 1;   // v starts at 1 rather than 0 for the same reason
+        int intLen = A[0].length;
+        int[] d = new int[A[0].length];
+
+        int slen = len / 2;
+        while (slen > 1) {   // slen = #consecutive coefficients for which the sign (add/sub) and x are constant
+            for (int j=0; j<len; j+=2*slen) {
+                int x1 = getDftExponent(n, v+1, j+expOffset, omega) * expScale;        // for level v+2
+                int x2 = getDftExponent(n, v, j+expOffset, omega) * expScale;          // for level v+1
+                int x3 = getDftExponent(n, v+1, j+slen+expOffset, omega) * expScale;   // for level v+2
+
+                // stride length = stride*slen subarrays
+                int idx0 = stride*j + idxOffset;
+                int idx1 = stride*j + stride*slen/2 + idxOffset;
+                int idx2 = idx0 + stride*slen;
+                int idx3 = idx1 + stride*slen;
+
+                for (int k=slen-1; k>=0; k-=2) {
+                    // do level v+1
+                    cyclicShiftLeftBits(A[idx2], x2, d);
+                    System.arraycopy(A[idx0], 0, A[idx2], 0, intLen);
+                    addModFn(A[idx0], d);
+                    subModFn(A[idx2], d);
+
+                    cyclicShiftLeftBits(A[idx3], x2, d);
+                    System.arraycopy(A[idx1], 0, A[idx3], 0, intLen);
+                    addModFn(A[idx1], d);
+                    subModFn(A[idx3], d);
+
+                    // do level v+2
+                    cyclicShiftLeftBits(A[idx1], x1, d);
+                    System.arraycopy(A[idx0], 0, A[idx1], 0, intLen);
+                    addModFn(A[idx0], d);
+                    subModFn(A[idx1], d);
+
+                    cyclicShiftLeftBits(A[idx3], x3, d);
+                    System.arraycopy(A[idx2], 0, A[idx3], 0, intLen);
+                    addModFn(A[idx2], d);
+                    subModFn(A[idx3], d);
+
+                    idx0 += stride;
+                    idx1 += stride;
+                    idx2 += stride;
+                    idx3 += stride;
+                }
+            }
+
+            v += 2;
+            slen /= 4;
+        }
+
+        // if there is an odd number of levels, do the remaining one now
+        if (slen > 0)
+            for (int j=0; j<len; j+=2*slen) {
+                int x = getDftExponent(n, v, j+expOffset, omega) * expScale;
+                int idx = stride*j + idxOffset;
+                int idx2 = idx + stride*slen;   // stride length = stride*slen subarrays
+
+                for (int k=slen-1; k>=0; k--) {
+                    cyclicShiftLeftBits(A[idx2], x, d);
+                    System.arraycopy(A[idx], 0, A[idx2], 0, intLen);
+                    addModFn(A[idx], d);
+                    subModFn(A[idx2], d);
+                    idx += stride;
+                    idx2 += stride;
+                }
+            }
+    }
+
+    /**
+     * Returns the power to which to raise omega in a DFT.<br/>
+     * When <code>omega</code>=4, this method doubles the exponent so
+     * <code>omega</code> can be assumed always to be 2 in {@link #dft(int[][], int)}.
+     * @param n the log of the DFT length
+     * @param v butterfly depth
+     * @param idx index of the array element to be computed
+     * @param omega 2 or 4
+     * @return
+     */
+    private static int getDftExponent(int n, int v, int idx, int omega) {
+        // x = 2^(n-1-v) * s, where s is the v (out of n) high bits of idx in reverse order
+        int x = Integer.reverse(idx >>> (n-v)) >>> (32-v);
+        x <<= n - v - 1;
+
+        // if omega=4, double the shift amount
+        if (omega == 4)
+            x *= 2;
+
+        return x;
+    }
+
+    /** Multiplies vector elements by powers of omega (aka twiddle factors) */
+    private static void applyDftWeights(int[][] A, int omega, int rows, int cols) {
+        int v = 31 - Integer.numberOfLeadingZeros(rows) + 1;
+
+        for (int i=0; i<rows; i++)
+            for (int j=0; j<cols; j++) {
+                int idx = i*cols + j;
+                int[] temp = new int[A[idx].length];
+                int shiftAmt = getBaileyShiftAmount(i, j, rows, cols, v);
+                if (omega == 4)
+                    shiftAmt *= 2;
+                cyclicShiftLeftBits(A[idx], shiftAmt, temp);
+                System.arraycopy(temp, 0, A[idx], 0, temp.length);
+            }
+    }
+
+    private static int getBaileyShiftAmount(int i, int j, int rows, int cols, int v) {
+        int iRev = Integer.reverse(i+rows) >>> (32-v);
+        return iRev * j;
+    }
+
+    /**
+     * Performs a modified
+     * <a href="http://en.wikipedia.org/wiki/Discrete_Fourier_transform_%28general%29#Number-theoretic_transform">
+     * Inverse Fermat Number Transform</a> on an array whose elements are <code>int</code> arrays.
+     * The modification is that the last step (the one where the upper half is subtracted from the lower half)
+     * is omitted.<br/>
+     * This implementation uses <a href="http://www.nas.nasa.gov/assets/pdf/techreports/1989/rnr-89-004.pdf">
+     * Bailey's 4-step algorithm</a>.<br/>
+     * <code>A</code> is assumed to be the upper half of the full array and the lower half is assumed to be all zeros.
+     * The number of subarrays in <code>A</code> must be 2<sup>n</sup> if m is even and 2<sup>n+1</sup> if m is odd.<br/>
+     * Each subarray must be ceil(2<sup>n-1</sup>) bits in length.<br/>
+     * n must be equal to m/2-1.
+     * @param A
+     * @param omega 2 or 4
+     */
+    private static void idft(int[][] A, int omega) {
+        // arrange the elements of A in a matrix roughly sqrt(A.length) by sqrt(A.length) in size
+        int rows = 1 << ((31-Integer.numberOfLeadingZeros(A.length))/2);   // number of rows
+        int cols = A.length / rows;   // number of columns
+
+        // step 1: perform an IDFT on each row
+        for (int i=0; i<rows; i++)
+            idftBailey2(A, omega, rows, cols, i);
+
+        // step 2: multiply by powers of omega
+        applyIdftWeights(A, omega, rows, cols);
+
+        // step 3 is built into step 4 by making the stride length a multiple of the row length
+        // step 4: perform an IDFT on each column
+        for (int i=0; i<cols; i++)
+            idftBailey1(A, omega, rows, cols, i);
+    }
+
+    /**
+     * Performs an IDFT on column {@code colIdx}.<br/>
+     * <code>A</code> is assumed to be the upper half of the full array.
+     * @param A an array of length rows*cols
+     * @param omega root of unity
+     * @param rows number of rows in A
+     * @param cols number of columns in A
+     * @param colIdx index of the column to transform
+     */
+    private static void idftBailey1(int[][] A, int omega, int rows, int cols, int colIdx) {
+        idftDirect1(A, omega, rows, rows, cols, colIdx, cols);
+    }
+
+    /** This implementation uses the radix-4 technique which combines two levels of butterflies. */
+    private static void idftDirect1(int[][] A, int omega, int len, int expOffset, int expScale, int idxOffset, int stride) {
+        int n = 31 - Integer.numberOfLeadingZeros(2*len);   // multiply by 2 because we're doing a half DFT and we need the n that corresponds to the full DFT length
+        int v = 31 - Integer.numberOfLeadingZeros(len);
+        int intLen = A[0].length;
+        int[] c = new int[intLen];
+
+        int slen = 1;
+        while (slen <= len/4) {   // slen = #consecutive coefficients for which the sign (add/sub) and x are constant
+            for (int j=0; j<len; j+=4*slen) {
+                int x1 = getDftExponent(n, v, j+expOffset, omega)*expScale + 1;          // for level v
+                int x2 = getDftExponent(n, v-1, j+expOffset, omega)*expScale + 1;        // for level v-1
+                int x3 = getDftExponent(n, v, j+slen*2+expOffset, omega)*expScale + 1;   // for level v
+
+                // stride length = stride*slen subarrays
+                int idx0 = stride*j + idxOffset;
+                int idx1 = stride*j + stride*slen + idxOffset;
+                int idx2 = idx0 + stride*slen*2;
+                int idx3 = idx1 + stride*slen*2;
+
+                for (int k=slen-1; k>=0; k--) {
+                    // do level v
+                    System.arraycopy(A[idx0], 0, c, 0, c.length);
+                    addModFn(A[idx0], A[idx1]);
+                    cyclicShiftRightBits(A[idx0], 1, A[idx0]);
+                    subModFn(c, A[idx1]);
+                    cyclicShiftRightBits(c, x1, A[idx1]);
+
+                    System.arraycopy(A[idx2], 0, c, 0, c.length);
+                    addModFn(A[idx2], A[idx3]);
+                    cyclicShiftRightBits(A[idx2], 1, A[idx2]);
+                    subModFn(c, A[idx3]);
+                    cyclicShiftRightBits(c, x3, A[idx3]);
+
+                    // do level v-1
+                    System.arraycopy(A[idx0], 0, c, 0, c.length);
+                    addModFn(A[idx0], A[idx2]);
+                    cyclicShiftRightBits(A[idx0], 1, A[idx0]);
+                    subModFn(c, A[idx2]);
+                    cyclicShiftRightBits(c, x2, A[idx2]);
+
+                    System.arraycopy(A[idx1], 0, c, 0, c.length);
+                    addModFn(A[idx1], A[idx3]);
+                    cyclicShiftRightBits(A[idx1], 1, A[idx1]);
+                    subModFn(c, A[idx3]);
+                    cyclicShiftRightBits(c, x2, A[idx3]);
+
+                    idx0 += stride;
+                    idx1 += stride;
+                    idx2 += stride;
+                    idx3 += stride;
+                }
+            }
+
+            v -= 2;
+            slen *= 4;
+        }
+
+        // if there is an odd number of levels, do the remaining one now
+        if (slen <= len/2)
+            for (int j=0; j<len; j+=2*slen) {
+                int x = getDftExponent(n, v, j+expOffset, omega)*expScale + 1;
+                int idx = stride*j + idxOffset;
+                int idx2 = idx + stride*slen;   // stride length = stride*slen subarrays
+
+                for (int k=slen-1; k>=0; k--) {
+                    System.arraycopy(A[idx], 0, c, 0, c.length);
+                    addModFn(A[idx], A[idx2]);
+                    cyclicShiftRightBits(A[idx], 1, A[idx]);
+
+                    subModFn(c, A[idx2]);
+                    cyclicShiftRightBits(c, x, A[idx2]);
+                    idx += stride;
+                    idx2 += stride;
+                }
+            }
+    }
+
+    /**
+     * Performs an IDFT on row {@code rowIdx}.<br/>
+     * <code>A</code> is assumed to be the upper half of the full array.
+     * @param A an array of length rows*cols
+     * @param omega root of unity
+     * @param rows number of rows in A
+     * @param cols number of columns in A
+     * @param rowIdx index of the row to transform
+     */
+    private static void idftBailey2(int[][] A, int omega, int rows, int cols, int rowIdx) {
+        idftDirect1(A, omega, cols, 0, rows, rowIdx*cols, 1);
+    }
+
+    /** Divides vector elements by powers of omega (aka twiddle factors) */
+    private static void applyIdftWeights(int[][] A, int omega, int rows, int cols) {
+        int v = 31 - Integer.numberOfLeadingZeros(rows) + 1;
+
+        for (int i=0; i<rows; i++)
+            for (int j=0; j<cols; j++) {
+                int idx = i*cols + j;
+                int[] temp = new int[A[idx].length];
+                int shiftAmt = getBaileyShiftAmount(i, j, rows, cols, v);
+                if (omega == 4)
+                    shiftAmt *= 2;
+                cyclicShiftRightBits(A[idx], shiftAmt, temp);
+                System.arraycopy(temp, 0, A[idx], 0, temp.length);
+            }
+    }
+
+    /**
+     * Adds two <b>positive</b> numbers (meaning they are interpreted as unsigned) modulo 2<sup>2<sup>n</sup></sup>+1,
+     * where n is <code>a.length*32/2</code>; in other words, n is half the number of bits in
+     * <code>a</code>.<br/>
+     * Both input values are given as <code>int</code> arrays; they must be the same length.
+     * The result is returned in the first argument.
+     * @param a a number in base 2<sup>32</sup> starting with the highest digit; the array's length must be a power of 2
+     * @param b a number in base 2<sup>32</sup> starting with the highest digit; must be the same length as a
+     */
+    private static void addModFn(int[] a, int[] b) {
+        boolean carry = false;
+        for (int i=a.length-1; i>=0; i--) {
+            int sum = a[i] + b[i];
+            if (carry)
+                sum++;
+            carry = ((sum>>>31) < (a[i]>>>31)+(b[i]>>>31));   // carry if signBit(sum) < signBit(a)+signBit(b)
+            a[i] = sum;
+        }
+
+        // take a mod Fn by adding any remaining carry bit to the lowest bit;
+        // since Fn is congruent to 1 (mod 2^n), it suffices to add 1
+        int i = a.length - 1;
+        while (carry) {
+            int sum = a[i] + 1;
+            a[i] = sum;
+            carry = sum == 0;
+            i--;
+            if (i < 0)
+                i = a.length;
+        }
+    }
+
+    /**
+     * Subtracts two <b>positive</b> numbers (meaning they are interpreted as unsigned) modulo 2<sup>2<sup>n</sup></sup>+1,
+     * where n is <code>a.length*32/2</code>; in other words, n is half the number of bits in
+     * <code>a</code>.<br/>
+     * Both input values are given as <code>int</code> arrays; they must be the same length.
+     * The result is returned in the first argument.
+     * @param a a number in base 2<sup>32</sup> starting with the highest digit; the array's length must be a power of 2
+     * @param b a number in base 2<sup>32</sup> starting with the highest digit; must be the same length as a
+     */
+    private static void subModFn(int[] a, int[] b) {
+        // subtraction works by shifting b by b.length/2, then adding a and b
+        boolean carry = false;
+        int bIdx = b.length/2 - 1;
+        for (int i=a.length-1; i>=a.length/2; i--) {
+            int sum = a[i] + b[bIdx];
+            if (carry)
+                sum++;
+            carry = ((sum>>>31) < (a[i]>>>31)+(b[bIdx]>>>31));   // carry if signBit(sum) < signBit(a)+signBit(b)
+            a[i] = sum;
+            bIdx--;
+        }
+        bIdx = b.length - 1;
+        for (int i=a.length/2-1; i>=0; i--) {
+            int sum = a[i] + b[bIdx];
+            if (carry)
+                sum++;
+            carry = ((sum>>>31) < (a[i]>>>31)+(b[bIdx]>>>31));   // carry if signBit(sum) < signBit(a)+signBit(b)
+            a[i] = sum;
+            bIdx--;
+        }
+
+        // take a mod Fn by adding any remaining carry bit to the lowest bit;
+        // since Fn is congruent to 1 (mod 2^n), it suffices to add 1
+        int i = a.length - 1;
+        while (carry) {
+            int sum = a[i] + 1;
+            a[i] = sum;
+            carry = sum == 0;
+            i--;
+            if (i < 0)
+                i = a.length;
+        }
+    }
+
+    /**
+     * Multiplies two <b>positive</b> numbers (meaning they are interpreted as unsigned) modulo 2<sup>n</sup>+1,
+     * and returns the result in a new array.<br/>
+     * <code>a</code> and <code>b</code> are assumed to be reduced mod 2<sup>n</sup>+1, i.e. 0&le;a&lt;2<sup>n</sup>+1
+     * and 0&le;b&lt;2<sup>n</sup>+1, where n is <code>a.length*32/2</code>; in other words, n is half the number
+     * of bits in <code>a</code>.<br/>
+     * Both input values are given as <code>int</code> arrays; they must be the same length.
+     * @param a a number in base 2<sup>32</sup> starting with the highest digit; the array's length must be a power of 2
+     * @param b a number in base 2<sup>32</sup> starting with the highest digit; must be the same length as a
+     */
+    private static int[] multModFn(int[] a, int[] b) {
+        int n = a.length / 2;
+        // The upper halves of a and b can only be 0 or 1 because a and b are reduced mod 2^n+1,
+        // so multiply just the lower halves of a and b. Handle the 3 special cases where one or
+        // both upper halves equal 1 (i.e., a[n-1]=1 and/or b[n-1]=1). The upper half of a number
+        // reduced modulo 2^n+1 equals 1 iff the number=2^n.
+        if (a[n-1] == 1) {
+            // if a=b=2^n, a*b=1 (mod 2^n+1)
+            if (b[n-1] == 1) {
+                int[] c = new int[a.length];
+                c[c.length-1] = 1;
+                return c;
+            }
+            // if a=2^n and b!=2^n+1, a*b=-b (mod 2^n+1)
+            else {
+                int[] b0pad = new int[a.length];
+                System.arraycopy(b, n, b0pad, n, n);
+                int[] c = new int[a.length];
+                subModFn(c, b0pad);
+                return c;
+            }
+        }
+        // if a!=2^n and b=2^n, a*b=-a (mod 2^n+1)
+        else if (b[n-1] == 1) {
+            int[] a0pad = new int[b.length];
+            System.arraycopy(a, n, a0pad, n, n);
+            int[] c = new int[b.length];
+            subModFn(c, a0pad);
+            return c;
+        }
+        // if a!=2^n and b!=2^n, a*b=a0*b0
+        else {
+            int[] a0 = Arrays.copyOfRange(a, n, a.length);
+            int[] b0 = Arrays.copyOfRange(b, n, b.length);
+            BigInteger aBigInt = new BigInteger(1, a0);
+            BigInteger bBigInt = new BigInteger(1, b0);
+            int[] c = aBigInt.multiply(bBigInt).mag;
+    
+            // make sure c is the same length as a and b
+            int[] cpad = new int[a.length];
+            System.arraycopy(c, 0, cpad, a.length-c.length, c.length);
+            return cpad;
+        }
+    }
+
+    /** @see #multModFn(int[], int[]) */
+    private static int[] squareModFn(int[] a) {
+        // if a=Fn-1, a^2=1 (mod Fn)
+        if (a[a.length/2-1] == 1) {
+            int[] c = new int[a.length];
+            c[c.length-1] = 1;
+            return c;
+        }
+
+        int[] a0 = Arrays.copyOfRange(a, a.length/2, a.length);
+        BigInteger aBigInt = new BigInteger(1, a0);
+        int[] c = aBigInt.square().mag;
+
+        // make sure c is the same length as a
+        int[] cpad = new int[a.length];
+        System.arraycopy(c, 0, cpad, a.length-c.length, c.length);
+
+        return cpad;
+    }
+
+    /**
+     * Reduces a number modulo F<sub>n</sub>. The value of n is determined from the array's length.
+     * @param a a number in base 2<sup>32</sup> starting with the highest digit; the array's length must be a power of 2
+     */
+    private static void modFn(int[] a) {
+        // Reduction modulo Fn is done by subtracting the upper half from the lower half
+        int len = a.length;
+        boolean carry = false;
+        for (int i=len-1; i>=len/2; i--) {
+            int bi = a[i-len/2];
+            int diff = a[i] - bi;
+            if (carry)
+                diff--;
+            carry = ((diff>>>31) > (a[i]>>>31)-(bi>>>31));   // carry if signBit(diff) > signBit(a)-signBit(b)
+            a[i] = diff;
+        }
+        for (int i=len/2-1; i>=0; i--)
+            a[i] = 0;
+        // if result is negative, add Fn; since Fn is congruent to 1 (mod 2^n), it suffices to add 1
+        if (carry) {
+            int j = len - 1;
+            do {
+                int sum = a[j] + 1;
+                a[j] = sum;
+                carry = sum == 0;
+                j--;
+                if (j <= 0)
+                    j = len;
+            } while (carry);
+        }
+    }
+
+    /**
+     * Reduces all subarrays modulo 2<sup>2<sup>n</sup></sup>+1 where n=<code>a[i].length*32/2</code> for all i;
+     * in other words, n is half the number of bits in the subarray.
+     * @param a int arrays whose length is a power of 2
+     */
+    private static void modFn(int[][] a) {
+        for (int i=0; i<a.length; i++)
+            modFn(a[i]);
+    }
+
+    /**
+     * Cyclicly shifts a number to the right modulo 2<sup>2<sup>n</sup></sup>+1, where n is
+     * <code>a.length*32/2</code>; in other words, n is half the number of bits in <code>a</code>.<br/>
+     * "Right" means towards the lower array indices and the lower bits; this is equivalent to
+     * a multiplication by 2<sup>-numBits</sup> modulo 2<sup>2<sup>n</sup></sup>+1.<br/>
+     * The result is returned in the third argument.
+     * @param a a number in base 2<sup>32</sup> starting with the highest digit; the array's length must be a power of 2
+     * @param numBits the shift amount in bits
+     * @param b the return value; must be at least as long as <code>a</code>
+     */
+    private static void cyclicShiftRightBits(int[] a, int numBits, int[] b) {
+        int numElements = numBits / 32;
+        System.arraycopy(a, 0, b, numElements, a.length-numElements);
+        System.arraycopy(a, a.length-numElements, b, 0, numElements);
+
+        numBits = numBits % 32;
+        if (numBits != 0) {
+            int bhi = b[b.length-1];
+            b[b.length-1] = b[b.length-1] >>> numBits;
+            for (int i=b.length-1; i>0; i--) {
+                b[i] |= b[i-1] << (32-numBits);
+                b[i-1] = b[i-1] >>> numBits;
+            }
+            b[0] |= bhi << (32-numBits);
+        }
+    }
+
+    /**
+     * Cyclicly shifts a number to the left modulo 2<sup>2<sup>n</sup></sup>+1, where n is
+     * <code>a.length*32/2</code>; in other words, n is half the number of bits in <code>a</code>.<br/>
+     * "Left" means towards the lower array indices and the lower bits; this is equivalent to
+     * a multiplication by 2<sup>numBits</sup> modulo 2<sup>2<sup>n</sup></sup>+1.<br/>
+     * The result is returned in the third argument.
+     * @param a a number in base 2<sup>32</sup> starting with the highest digit; the array's length must be a power of 2
+     * @param numBits the shift amount in bits
+     * @param b the return value; must be at least as long as <code>a</code>
+     */
+    private static void cyclicShiftLeftBits(int[] a, int numBits, int[] b) {
+        int numElements = numBits / 32;
+        System.arraycopy(a, numElements, b, 0, a.length-numElements);
+        System.arraycopy(a, 0, b, a.length-numElements, numElements);
+
+        numBits = numBits % 32;
+        if (numBits != 0) {
+            int b0 = b[0];
+            b[0] <<= numBits;
+            for (int i=1; i<b.length; i++) {
+                b[i-1] |= b[i] >>> (32-numBits);
+                b[i] <<= numBits;
+            }
+            b[b.length-1] |= b0 >>> (32-numBits);
+        }
+    }
+
+    /**
+     * Adds two numbers, <code>a</code> and <code>b</code>, after shifting <code>b</code> by
+     * <code>numElements</code> elements.<br/>
+     * Both numbers are given as <code>int</code> arrays and must be <b>positive</b> numbers
+     * (meaning they are interpreted as unsigned).<br/>
+     * The result is returned in the first argument.
+     * If any elements of b are shifted outside the valid range for <code>a</code>, they are dropped.
+     * @param a a number in base 2<sup>32</sup> starting with the highest digit
+     * @param b a number in base 2<sup>32</sup> starting with the highest digit
+     * @param numElements
+     */
+    private static void addShifted(int[] a, int[] b, int numElements) {
+        boolean carry = false;
+        int aIdx = a.length - 1 - numElements;
+        int bIdx = b.length - 1;
+        int i = Math.min(aIdx, bIdx);
+        while (i >= 0) {
+            int ai = a[aIdx];
+            int sum = ai + b[bIdx];
+            if (carry)
+                sum++;
+            carry = ((sum>>>31) < (ai>>>31)+(b[bIdx]>>>31));   // carry if signBit(sum) < signBit(a)+signBit(b)
+            a[aIdx] = sum;
+            i--;
+            aIdx--;
+            bIdx--;
+        }
+        while (carry && aIdx>=0) {
+            a[aIdx]++;
+            carry = a[aIdx] == 0;
+            aIdx--;
+        }
+    }
+
+    /**
+     * Adds two <b>positive</b> numbers (meaning they are interpreted as unsigned) modulo 2<sup>numBits</sup>.
+     * Both input values are given as <code>int</code> arrays.
+     * The result is returned in the first argument.
+     * @param a a number in base 2<sup>32</sup> starting with the highest digit
+     * @param b a number in base 2<sup>32</sup> starting with the highest digit
+     */
+    private static void addModPow2(int[] a, int[] b, int numBits) {
+        int numElements = (numBits+31) / 32;
+        boolean carry = false;
+        int i;
+        int aIdx = a.length - 1;
+        int bIdx = b.length - 1;
+        for (i=numElements-1; i>=0; i--) {
+            int sum = a[aIdx] + b[bIdx];
+            if (carry)
+                sum++;
+            carry = ((sum>>>31) < (a[aIdx]>>>31)+(b[bIdx]>>>31));   // carry if signBit(sum) < signBit(a)+signBit(b)
+            a[aIdx] = sum;
+            aIdx--;
+            bIdx--;
+        }
+        if (numElements > 0)
+            a[aIdx+1] &= -1 >>> (32-(numBits%32));
+        for (; aIdx>=0; aIdx--)
+            a[aIdx] = 0;
+    }
+
+    /**
+     * Subtracts two <b>positive</b> numbers (meaning they are interpreted as unsigned) modulo 2<sup>numBits</sup>.
+     * Both input values are given as <code>int</code> arrays.
+     * The result is returned in the first argument.
+     * @param a a number in base 2<sup>32</sup> starting with the highest digit
+     * @param b a number in base 2<sup>32</sup> starting with the highest digit
+     */
+    private static void subModPow2(int[] a, int[] b, int numBits) {
+        int numElements = (numBits+31) / 32;
+        boolean carry = false;
+        int i;
+        int aIdx = a.length - 1;
+        int bIdx = b.length - 1;
+        for (i=numElements-1; i>=0; i--) {
+            int diff = a[aIdx] - b[bIdx];
+            if (carry)
+                diff--;
+            carry = ((diff>>>31) > (a[aIdx]>>>31)-(b[bIdx]>>>31));   // carry if signBit(diff) > signBit(a)-signBit(b)
+            a[aIdx] = diff;
+            aIdx--;
+            bIdx--;
+        }
+        if (numElements > 0)
+            a[aIdx+1] &= -1 >>> (32-(numBits%32));
+        for (; aIdx>=0; aIdx--)
+            a[aIdx] = 0;
+    }
+
+    /**
+     * Reads <code>bBitLength</code> bits from <code>b</code>, starting at array index
+     * <code>bStart</code>, and copies them into <code>a</code>, starting at bit
+     * <code>aBitLength</code>. The result is returned in <code>a</code>.
+     * @param a
+     * @param aBitLength
+     * @param b
+     * @param bStart
+     * @param bBitLength
+     */
+    private static void appendBits(int[] a, int aBitLength, int[] b, int bStart, int bBitLength) {
+        int aIdx = a.length - 1 - aBitLength/32;
+        int bit32 = aBitLength % 32;
+
+        int bIdx = b.length - 1 - bStart;
+        int bIdxStop = bIdx - bBitLength/32;
+        while (bIdx > bIdxStop) {
+            if (bit32 > 0) {
+                a[aIdx] |= b[bIdx] << bit32;
+                aIdx--;
+                a[aIdx] = b[bIdx] >>> (32-bit32);
+            }
+            else {
+                a[aIdx] = b[bIdx];
+                aIdx--;
+            }
+            bIdx--;
+        }
+
+        if (bBitLength%32 > 0) {
+            int bi = b[bIdx];
+            bi &= -1 >>> (32-bBitLength%32);
+            a[aIdx] |= bi << bit32;
+            if (bit32+(bBitLength%32) > 32)
+                a[aIdx-1] = bi >>> (32-bit32);
+        }
+    }
+
+    /**
+     * Divides an <code>int</code> array into pieces <code>bitLength</code> bits long.
+     * @param a
+     * @param bitLength
+     * @return a new array containing <code>bitLength</code> bits from <code>a</code> in each subarray
+     */
+    private static int[][] splitBits(int[] a, int bitLength) {
+        int aIntIdx = a.length - 1;
+        int aBitIdx = 0;
+        int numPieces = (a.length*32+bitLength-1) / bitLength;
+        int pieceLength = (bitLength+31) / 32;   // in ints
+        int[][] b = new int[numPieces][pieceLength];
+        for (int i=0; i<b.length; i++) {
+            int bitsRemaining = Math.min(bitLength, a.length*32-i*bitLength);
+            int bIntIdx = bitLength / 32;
+            if (bitLength%32 == 0)
+                bIntIdx--;
+            int bBitIdx = 0;
+            while (bitsRemaining > 0) {
+                int bitsToCopy = Math.min(32-aBitIdx, 32-bBitIdx);
+                bitsToCopy = Math.min(bitsRemaining, bitsToCopy);
+                int mask = a[aIntIdx] >>> aBitIdx;
+                mask &= -1 >>> (32-bitsToCopy);
+                mask <<= bBitIdx;
+                b[i][bIntIdx] |= mask;
+                bitsRemaining -= bitsToCopy;
+                aBitIdx += bitsToCopy;
+                if (aBitIdx >= 32) {
+                    aBitIdx -= 32;
+                    aIntIdx--;
+                }
+                bBitIdx += bitsToCopy;
+                if (bBitIdx >= 32) {
+                    bBitIdx -= 32;
+                    bIntIdx--;
+                }
+            }
+        }
+        return b;
+    }
+
+    /**
+     * Splits an <code>int</code> array into pieces of <code>pieceSize ints</code> each, and
+     * pads each piece to <code>targetPieceSize ints</code>.
+     * @param a the input array
+     * @param numPieces the number of pieces to split the array into
+     * @param pieceSize the size of each piece in the input array in <code>ints</code>
+     * @param targetPieceSize the size of each piece in the output array in <code>ints</code>
+     * @return an array of length <code>numPieces</code> containing subarrays of length <code>targetPieceSize</code>
+     */
+    private static int[][] splitInts(int[] a, int numPieces, int pieceSize, int targetPieceSize) {
+        int[][] ai = new int[numPieces][targetPieceSize];
+        int aIdx = a.length - pieceSize;
+        int pieceIdx = 0;
+        while (aIdx >= 0) {
+            System.arraycopy(a, aIdx, ai[pieceIdx], targetPieceSize-pieceSize, pieceSize);
+            aIdx -= pieceSize;
+            pieceIdx++;
+        }
+        System.arraycopy(a, 0, ai[a.length/pieceSize], targetPieceSize-(a.length%pieceSize), a.length%pieceSize);
+        return ai;
+    }
+
@@ -1874 +2995,4 @@
-                return squareToomCook3();
+                if (!shouldSquareSchoenhageStrassen(len))
+                    return squareToomCook3();
+                else
+                    return squareSchoenhageStrassen();
@@ -2032 +3156,5 @@
-            return divideBurnikelZiegler(val);
+            if (!shouldDivideBarrett(mag.length) || !shouldDivideBarrett(val.mag.length)) {
+                return divideBurnikelZiegler(val);
+            } else {
+                return divideBarrett(val);
+            }
@@ -2069 +3197,42 @@
-            return divideAndRemainderBurnikelZiegler(val);
+            if (!shouldDivideBarrett(mag.length) || !shouldDivideBarrett(val.mag.length)) {
+                return divideAndRemainderBurnikelZiegler(val);
+            } else {
+                return divideAndRemainderBarrett(val);
+            }
+        }
+    }
+
+    /**
+     * Estimates whether Barrett Division will be more efficient than Burnikel-Ziegler when
+     * dividing two numbers of a given length in bits.
+     * @param length the number of ints in each of the two inputs
+     * @return <code>true</code> if Barrett is more efficient, <code>false</code> if Burnikel-Ziegler is more efficient
+     */
+    static boolean shouldDivideBarrett(int length) {
+        if (IS64BIT) {
+            // The following values were determined experimentally on a 64-bit JVM.
+            if (length <= 123000)
+                return false;
+            if (length <= 131072)   // 2^17
+                return true;
+            if (length <= 206000)
+                return false;
+            if (length <= 262144)   // 2^18
+                return true;
+            if (length <= 345000)
+                return false;
+            if (length <= 524288)   // 2^19
+                return true;
+            if (length <= 595000)
+                return false;
+            return true;
+        }
+        else {
+            // The following values were determined experimentally on a 32-bit JVM.
+            if (length <= 101000)
+                return false;
+            if (length <= 131072)   // 2^17
+                return true;
+            if (length <= 177000)
+                return false;
+            return true;
@@ -2098 +3267,5 @@
-            return remainderBurnikelZiegler(val);
+            if (!shouldDivideBarrett(mag.length) || !shouldDivideBarrett(val.mag.length)) {
+                return remainderBurnikelZiegler(val);
+            } else {
+                return remainderBarrett(val);
+            }
@@ -2140,0 +3314,160 @@
+    }
+
+    /** Barrett division */
+    private BigInteger divideBarrett(BigInteger val) {
+        return divideAndRemainderBarrett(val)[0];
+    }
+
+    /** Barrett division */
+    private BigInteger remainderBarrett(BigInteger val) {
+        return divideAndRemainderBarrett(val)[1];
+    }
+
+    /**
+     * Computes <code>this/val</code> and <code>this%val</code> using Barrett division.
+     * @param val the divisor
+     * @return an array containing the quotient and remainder
+     */
+    private BigInteger[] divideAndRemainderBarrett(BigInteger val) {
+        BigInteger[] c = abs().divideAndRemainderBarrettPositive(val.abs());
+        if (signum*val.signum < 0)
+            c[0] = c[0].negate();
+        if (signum < 0)
+            c[1] = c[1].negate();
+        return c;
+    }
+
+    /**
+     * Computes <code>this/val</code> and <code>this%val</code> using Barrett division.
+     * <code>val</code> must be positive.
+     * @param val the divisor
+     * @return an array containing the quotient and remainder
+     */
+    private BigInteger[] divideAndRemainderBarrettPositive(BigInteger val) {
+        int m = bitLength();
+        int n = val.bitLength();
+
+        if (m < n)
+            return new BigInteger[] {ZERO, this};
+        else {
+            int lowestSetBit = Math.min(getLowestSetBit(), val.getLowestSetBit());
+            // Cancel common powers of two if it will speed up division, which is
+            // the case iff it reduces bitLength() below the next lower power of two.
+            if (Integer.numberOfLeadingZeros(n) < Integer.numberOfLeadingZeros(n-lowestSetBit)) {
+                BigInteger[] result = shiftRight(lowestSetBit).divideAndRemainder(val.shiftRight(lowestSetBit));
+                result[1].shiftLeft(lowestSetBit);
+                return result;
+            }
+
+            if (m <= 2*n) {
+                // this case is handled by Barrett directly
+                BigInteger mu = val.inverse(m-n);
+                return barrettBase(val, mu);
+            }
+            else {
+                // treat each n-bit piece of a as a digit and do long division by val
+                // (which is also n bits), reusing the inverse
+                BigInteger mu2n = val.inverse(n);
+                int startBit = m / n * n;   // the bit at which the current n-bit piece starts
+                BigInteger quotient = ZERO;
+                BigInteger remainder = shiftRight(startBit);
+                BigInteger mask = ONE.shiftLeft(n).subtract(ONE);   // n ones
+                while (startBit > 0) {
+                    startBit -= n;
+                    BigInteger ai = shiftRight(startBit).and(mask);
+                    remainder = remainder.shiftLeft(n).add(ai);
+                    BigInteger mu = mu2n.shiftRightRounded(2*n-remainder.bitLength());   // mu = 2^(remainder.length-n)/val
+                    BigInteger[] c = remainder.barrettBase(val, mu);
+                    quotient = quotient.shiftLeft(n).add(c[0]);
+                    remainder = c[1];
+                }
+                return new BigInteger[] {quotient, remainder};
+            }
+        }
+    }
+
+    /**
+     * Computes <code>this/b</code> and <code>this%b</code>.
+     * The binary representation of <code>b</code> must be at least half as
+     * long, and no longer than, the binary representation of <code>a</code>.<br/>
+     * This method uses the Barrett algorithm as described in
+     * <a href="http://treskal.com/kalle/exjobb/original-report.pdf">
+     * Fast Division of Large Integers</a>, pg 17.
+     * @param b
+     * @param mu 2<sup>n</sup>/b where <code>n</code> is the number of binary digits of <code>this</code>
+     * @return an array containing the quotient and remainder
+     */
+    private BigInteger[] barrettBase(BigInteger b, BigInteger mu) {
+        int m = bitLength();
+        int n = b.bitLength();
+
+        BigInteger a1 = shiftRight(n-1);
+        BigInteger q = a1.multiply(mu).shiftRight(m-n+1);
+        BigInteger r = subtract(b.multiply(q));
+        while (r.signum()<0 || r.compareTo(b)>=0)
+            if (r.signum() < 0) {
+                r = r.add(b);
+                q = q.subtract(ONE);
+            }
+            else {
+                r = r.subtract(b);
+                q = q.add(ONE);
+            }
+        return new BigInteger[] {q, r};
+    }
+
+    /**
+     * Computes 2<sup>bitLength()+n</sup>/this.<br/>
+     * Uses the
+     * <a href="http://en.wikipedia.org/wiki/Division_%28digital%29#Newton.E2.80.93Raphson_division">
+     * Newton algorithm</a> as described in
+     * <a href="http://treskal.com/kalle/exjobb/original-report.pdf">
+     * Fast Division of Large Integers</a>, pg 23.
+     * @param n precision in bits
+     * @return <code>1/this</code>, shifted to the left by <code>bitLength()+n</code> bits
+     */
+    private BigInteger inverse(int n) {
+        int m = bitLength();
+        if (n <= NEWTON_THRESHOLD)
+            return ONE.shiftLeft(n*2).divideKnuth(shiftRightRounded(m-n));
+
+        // let numSteps = ceil(log2(n/NEWTON_THRESHOLD)) and initialize k
+        int numSteps = bitLengthForInt((n+NEWTON_THRESHOLD-1)/NEWTON_THRESHOLD);
+        int[] k = new int[numSteps];
+        int ki = n;
+        for (int i=numSteps-1; i>=0; i--) {
+            ki = (ki+1) / 2;
+            k[i] = ki<NEWTON_THRESHOLD ? NEWTON_THRESHOLD : ki;
+        }
+
+        // calculate 1/this truncated to k0 fraction digits
+        BigInteger z = ONE.shiftLeft(k[0]*2).divideKnuth(shiftRightRounded(m-k[0]));   // exp=k0 because exp(this)=m
+
+        for (int i=0; i<numSteps; i++) {
+            ki = k[i];
+            // the following BigIntegers represent numbers of the form a*2^(-exponent)
+            BigInteger s = z.square();   // exponent = 2ki
+            BigInteger t = shiftRightRounded(m-2*ki-3);   // exponent = 2ki+3
+            BigInteger u = t.multiply(s);   // exponent = 4ki+3 > 2ki+1
+            BigInteger w = z.add(z);   // exponent = ki
+            w = w.shiftLeft(3*ki+3);   // increase #fraction digits to 4ki+3 to match u
+            z = w.subtract(u);   // exponent = 4ki+3
+            if (i < numSteps-1)
+                z = z.shiftRightRounded(4*ki+3-k[i+1]);   // reduce #fraction digits to k[i+1]
+            else
+                z = z.shiftRightRounded(4*ki+3-n);   // final step: reduce #fraction digits to n
+        }
+        return z;
+    }
+
+    /**
+     * Same as {@link BigInteger#shiftRight(int)} but rounds to the
+     * nearest integer.
+     * @param n shift distance, in bits.
+     * @return round(this*2<sup>-n</sup>)
+     */
+    private BigInteger shiftRightRounded(int n) {
+        BigInteger b = shiftRight(n);
+        if (n>0 && testBit(n-1))
+            b = b.add(ONE);
+        return b;
